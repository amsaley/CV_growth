---
title: "CV growth"
output: html_document
date: "2023-09-20"
editor_options: 
  chunk_output_type: console
---

loading in library and data files
```{r}
setwd("C:/Users/alish/OneDrive/Documents/GitHub/CV_growth/data files")
library(readxl)
library(lme4)
library(lmerTest)
library(nlme)
dat = read.csv("C:/Users/alish/OneDrive/Documents/GitHub/CV_growth/data files/dat.processed.csv")
sw = read_xlsx("treatment monitoring.xlsx")


control = read_xlsx("control cv.xlsx")

```
grouping treatments by treatments; creating end and inc
```{r}
dat$T. = 0
dat[dat$sal.treat.x == "amb" & dat$TA.treat.x == "1000",]$T. <- "T1"
dat[dat$sal.treat.x == "amb" & dat$TA.treat.x == "2000",]$T. = "T2"
dat[dat$sal.treat.x == "amb" & dat$TA.treat.x == "3000",]$T. = "T3"

dat[dat$sal.treat.x == "low" & dat$TA.treat.x == "1000",]$T. = "t1"
dat[dat$sal.treat.x == "low" & dat$TA.treat.x == "2000",]$T. = "t2"
dat[dat$sal.treat.x == "low" & dat$TA.treat.x == "3000",]$T. = "t3"

nT1 = nrow(dat[dat$T. == "T1" & dat$dps == 36,])
nT2 = nrow(dat[dat$T. == "T2" & dat$dps == 36,])
nT3 = nrow(dat[dat$T. == "T3" & dat$dps == 36,])
nt1 = nrow(dat[dat$T. == "t1" & dat$dps == 36,])
nt2 = nrow(dat[dat$T. == "t2" & dat$dps == 36,])
nt3 = nrow(dat[dat$T. == "t3" & dat$dps == 36,])

dat$nrow = 0
dat[dat$T. == "T1",]$nrow <- nT1
dat[dat$T. == "T2",]$nrow <- nT2
dat[dat$T. == "T3",]$nrow <- nT3
dat[dat$T. == "t1",]$nrow <- nt1
dat[dat$T. == "t2",]$nrow <- nt2
dat[dat$T. == "t3",]$nrow <- nt3

#Removing outlier points from the data set
plot(dat$Net_growth.d)
summary(dat$Net_growth.d)
q1 = 0.1952  
q3 = 0.8105  
iqr = q3-q1
max = q3+(1.5*iqr)
  min = q1-(1.5*iqr)
plot(dat$Net_growth.d)
abline(h=c(min,max))


#after 5 weeks of exposure
end = subset(dat,
             dps == 36)
end$Net_growth.w.trans = log(end$Net_growth.w + 10)

plot((Net_growth.w.trans) ~ med.ta, pch = 19, col = as.factor(sal.treat.x), data = end)

#for incremental growth we need to delete the first time step
inc = subset(dat,
             dps >1)

#adding in a column for thickness of shell
end$thick.mgmm2 = end$shell.wt/end$SA.mm2.RE

common_ids = unique(dat[dat$Net_growth.d < max,]$CV_ID)

subset_end <- end[end$CV_ID %in% common_ids, ]
subset_inc <- inc[inc$CV_ID %in% common_ids, ]

end = subset_end
inc = subset_inc

```

MODELS ------------------------

summary stats for different treatments
```{r}
#ambient salinity
amb.S = as.data.frame(end[end$sal.treat.x == "amb",])
#low salinity
low.S = as.data.frame(end[end$sal.treat.x == "low",])
```

```{r}
inc$SA.imp = NA

inc[inc$dps == 36,]$SA.imp = inc[inc$dps == 36,]$SA.dps18

inc[inc$dps == 18,]$SA.imp = inc[inc$dps == 18,]$SA.start

inc$inc.d.mm2 = NA
inc$inc.d.mm2 = inc$incr_growth.d/inc$SA.imp

boxplot(inc.d.mm2 ~ TA.treat.x + sal.treat.x  + dps, data = inc[inc$SA.imp < 150,], outline = F)

boxplot(inc.d.mm2 ~ TA.treat.x + sal.treat.x  + dps, data = inc[inc$SA.imp > 150,], outline = F)

boxplot(Net_growth.d ~ TA.treat.x + sal.treat.x  + dps, data = inc[inc$SA.imp < 150,], outline = F)

boxplot(Net_growth.d ~ TA.treat.x + sal.treat.x  + dps, data = inc[inc$SA.imp > 150,], outline = F)


```
Checking assumptions of ANOVA model:
1. Normality – Each sample was drawn from a normally distributed population, ie The errors or residuals are normally distributed. This can be checked by using a normality test or a QQ-plot.

2. Equal Variances – The variances of the populations that the samples come from are equal. The errors or residuals have constant variance, mean zero, and are independent. This can be checked by plotting the residuals against the predictors and looking for any patterns or outliers.

3. Independence – The observations in each group are independent of each other and the observations within groups were obtained by a random sample. This can be resolved with random effects.

Checking the assumptions of an LME
The model you've specified using lme in R is a linear mixed-effects model. There are several assumptions associated with this type of model that you should verify to ensure the validity of your results and conclusions. Let's discuss the key assumptions and how you can check them in R:

Linearity:
Assumption: The relationship between the predictor variables (SA.start and TA.treat.x) and the response variable (Net_growth.d.TRANS) is linear.
Verification: Plot residuals against the fitted values and predictor variables to check for linearity.

Normality of Residuals:
Assumption: The residuals are normally distributed.
Verification: Plot a histogram or a Q-Q plot of the residuals to assess their normality.

Homoscedasticity of Residuals:
Assumption: The residuals have constant variance (homoscedasticity).
Verification: Plot residuals against the fitted values or predictor variables to check for patterns or changes in variance.

Independence of Residuals:
Assumption: The residuals are independent of each other.
Verification: Plot residuals against time or any other relevant variable to check for autocorrelation or patterns.

Random Effects Assumption:
Assumption: The random effects (random intercepts for the 'bucket' variable) are normally distributed and independent of other variables.
Verification: Check the distribution of the random effects using summary statistics or plots.

Model Fit:
Assumption: The model fits the data well.
Verification: Examine model fit statistics such as AIC (Akaike Information Criterion) or BIC (Bayesian Information Criterion) to evaluate the model's fit.


    MODEL 1: How does the effect of [TA] on shell growth (surface area) at ambient and lower salinity change over time?
shows that: there is no difference between salinity groups, there is a positive effect of size, there is no impact of TA initially, there is a negative impact of the later period, however the later period interacts with TA and S differently, producing a positive effect with TA later on, and a negative effect of low S relative to amb.
```{r}
library(nlme)
mod = (lme(Diff_growth ~  factor(sal.treat.x) + SA.imp  + med.ta + dps + med.ta:factor(dps) + factor(sal.treat.x):factor(dps) + SA.imp:factor(dps), random = list(CV_ID = pdIdent(~1), bucket = pdIdent(~1)), data = inc))

summary(mod)

#testing assumptions
#look at the spread of the residuals of the model
plot(resid(mod))
plot(resid(mod) ~ inc$med.ta)
boxplot(resid(mod)~ inc$sal.treat.x)
plot(resid(mod)~ inc$SA.imp)
boxplot(resid(mod)~ inc$dps)

#look at the distribution of residuals
hist(resid(mod)) #looks okay!

#look at the normality w qqplot: not bad...
qqnorm(resid(mod))
qqline(resid(mod))

plot(resid(mod) ~ fitted(mod)) #looks okay

#Independence: added in ID as a random intercept

# Fit the full model with the random effect
mod.full <- (lme(Diff_growth ~ factor(sal.treat.x)
                 + SA.imp
                 + med.ta
                 + factor(dps)
                 + med.ta:factor(dps)
                 + factor(sal.treat.x):factor(dps),
                 random = list(CV_ID = pdIdent(~1),
                          bucket = pdIdent(~1)),
                 data = inc))

# Fit the null model without the random effect
mod.ID <- (lme(Diff_growth ~ factor(sal.treat.x)
                 + SA.imp
                 + med.ta
                 + factor(dps)
                 + med.ta:factor(dps)
                 + factor(sal.treat.x):factor(dps),
                 random = ~1| bucket,
                 data = inc))
# Fit the null model without the random effect
mod.bucket <- (lme(Diff_growth ~ factor(sal.treat.x)
                 + SA.imp
                 + med.ta
                 + factor(dps)
                 + med.ta:factor(dps)
                 + factor(sal.treat.x):factor(dps),
                 random = ~1| CV_ID,
                 data = inc))
# Perform the likelihood ratio test 
anova(mod.full, mod.ID)    #effect of RE ID

anova(mod.full, mod.bucket)    #effect of bucket

mod.full <- (lm(Diff_growth ~ factor(sal.treat.x)
                 + SA.imp
                 + med.ta
                 + factor(dps)
                 + med.ta:factor(dps)
                 + factor(sal.treat.x):factor(dps)
                 + SA.imp:factor(dps),
                 data = inc))
mod.TATime <- lm(Diff_growth ~ factor(sal.treat.x)
                 + SA.imp
                 + med.ta
                 + factor(dps)
                 + factor(sal.treat.x):factor(dps)                             + SA.imp:factor(dps), 
               data = inc)
mod.STime <- lm(Diff_growth ~ factor(sal.treat.x)
                 + SA.imp
                 + med.ta
                 + factor(dps)
                 + med.ta:factor(dps)
                 + SA.imp:factor(dps), 
               data = inc)
mod.SAtime <- (lm(Diff_growth ~ factor(sal.treat.x)
                 + SA.imp
                 + med.ta
                 + factor(dps)
                 + med.ta:factor(dps)
                 + factor(sal.treat.x):factor(dps),
                 data = inc))

mod.SA <- lm(Diff_growth ~ factor(sal.treat.x)
                 + med.ta
                 + factor(dps)
                 + med.ta:factor(dps)
                 + factor(sal.treat.x):factor(dps)
                 + SA.imp:factor(dps), 
               data = inc)
mod.time <- lm(Diff_growth ~ factor(sal.treat.x)
                 + SA.imp
                 + med.ta
                 + med.ta:factor(dps)
                 + factor(sal.treat.x):factor(dps)
                 + SA.imp:factor(dps), 
               data = inc)


# Perform the likelihood ratio test  
anova(mod.full, mod.TATime)    #effect of TA later on
anova(mod.full, mod.STime)    #effect of S later on
anova(mod.full, mod.SAtime)       #effect of time on the relat between SA and growth overall
anova(mod.full, mod.SA)   
anova(mod.full, mod.time)  

mod.final = (lme(Diff_growth ~  factor(sal.treat.x) + SA.imp  + med.ta + dps + med.ta:factor(dps) + factor(sal.treat.x):factor(dps) + SA.imp:factor(dps), random = list(CV_ID = pdIdent(~1),bucket = pdIdent(~1)), data = inc))
#what is the goodness of fit? 
library(MuMIn)
r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```

    MODEL 2: What is the net effect of TA and S on shell growth, thickness, and condition index?

NET SHELL GROWTH; shows overall, no effect of TA or S on growth, but an effect of size
    ```{r}
mod = lme(Net_growth ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end,
           weights = varIdent(form = ~ 1 | bucket))  
    # Use the inverse of squared residuals as weights)
summary(mod)
#testing assumptions
#look at the spread of the residuals of the model
plot(resid(mod))
plot(resid(mod) ~ end$med.ta)
boxplot(resid(mod)~ end$sal.treat.x)
plot(resid(mod)~ end$SA.start)

#look at the distribution of residuals
hist(resid(mod)) #looks okay!

#look at the normality w qqplot: not bad...
qqnorm(resid(mod))
qqline(resid(mod))

plot(resid(mod) ~ fitted(mod)) #not okay and so we add the weights in!

#Independence: added in bucket as a random intercept

# Fit the full model with the random effect
mod.full <- lme(Net_growth ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end,
           weights = varIdent(form = ~ 1 | bucket))  
    # Use the inverse of squared residuals as weights)

# Fit the null model without the random effect
mod.null <- gls(Net_growth ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           data = end,
           weights = varIdent(form = ~ 1 | bucket))  
    # Use the inverse of squared residuals as weights)
# Perform the likelihood ratio test 
anova(mod.full, mod.null)    #effect of RE

mod.full <- lm(Net_growth ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           data = end)

mod.size <- lm(Net_growth ~  factor(sal.treat.x)
           + med.ta,
           data = end)  

# Perform the likelihood ratio test  
anova(mod.full, mod.size)    #effect of Size

mod.final <- lme(Net_growth ~ factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end,
           weights = varIdent(form = ~ 1 | bucket))
#what is the goodness of fit? 
library(MuMIn)
r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```
NET SHELL THICKNESS; shows that there a positive trend of TA on shell thickness, not sig; no effect of S or size
```{r}
end = end[end$thick.mgmm2 < 4.5,]
mod = lme(thick.mgmm2 ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end)

#testing assumptions
#look at the spread of the residuals of the model
plot(resid(mod))
plot(resid(mod) ~ end$med.ta)
boxplot(resid(mod)~ end$sal.treat.x)
plot(resid(mod)~ end$SA.start)

#look at the distribution of residuals
hist(resid(mod)) #looks okay!

#look at the normality w qqplot: not bad...
qqnorm(resid(mod))
qqline(resid(mod))

plot(resid(mod) ~ fitted(mod)) #looks ok!

#Independence: added in bucket as a random intercept

# Fit the full model with the random effect
mod.full <- lme(thick.mgmm2 ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end)

# Fit the null model without the random effect
mod.null <- gls(thick.mgmm2 ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           data = end)
# Perform the likelihood ratio test 
anova(mod.full, mod.null)    #effect of RE

mod.full <- lm(thick.mgmm2 ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           data = end)

mod.size <- lm(thick.mgmm2 ~  factor(sal.treat.x)
           + med.ta,
           data = end)  

mod.S <- lm(thick.mgmm2 ~ SA.start
           + med.ta,
           data = end)
mod.TA <- lm(thick.mgmm2 ~  factor(sal.treat.x)
           + SA.start,
           data = end)
# Perform the likelihood ratio test  
anova(mod.full, mod.size)
anova(mod.full, mod.S)    
anova(mod.full, mod.TA)    


mod.final <- lme(thick.mgmm2 ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end)
#what is the goodness of fit? 
library(MuMIn)
r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```
NET CONDITION INDEX; shows that there is a positive effect of size, but no effect of S or TA on condition index
```{r}
mod = lme(CI ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end)

#testing assumptions
#look at the spread of the residuals of the model
plot(resid(mod))
plot(resid(mod) ~ end$med.ta)
boxplot(resid(mod)~ end$sal.treat.x)
plot(resid(mod)~ end$SA.start)

#look at the distribution of residuals
hist(resid(mod)) #looks okay!

#look at the normality w qqplot: not bad...
qqnorm(resid(mod))
qqline(resid(mod))

plot(resid(mod) ~ fitted(mod)) #looks ok!

#Independence: added in bucket as a random intercept

# Fit the full model with the random effect
mod.full <- lme(CI ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end)

# Fit the null model without the random effect
mod.null <- gls(CI ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           data = end)
# Perform the likelihood ratio test 
anova(mod.full, mod.null)    #effect of RE

mod.full <- lm(CI ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           data = end)

mod.size <- lm(CI ~  factor(sal.treat.x)
           + med.ta,
           data = end)  

# Perform the likelihood ratio test  
anova(mod.full, mod.size)    #effect of Size



mod.final <- lme(CI ~  factor(sal.treat.x)
           + SA.start
           + med.ta,
           random = ~1| bucket,
           data = end)
#what is the goodness of fit? 
library(MuMIn)
r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```

      FIGURES:
###Figure 2: treatment conditions
summarizing conditions first
```{r}
library(dplyr)
median.sw.conditions <- sw %>%
  group_by(Date, `Bucket#`) %>%
  summarize(med_TA = mean(TA), med_S = mean(S), med_pH = mean(pH), med_T = mean(T_c), S.treat = NA, TA.treat = NA)

median.sw.conditions[median.sw.conditions$med_S > 30,]$S.treat <- 34
median.sw.conditions[median.sw.conditions$med_S < 30,]$S.treat <- 27

median.sw.conditions[median.sw.conditions$med_S > 30,]$TA.treat <- 34
median.sw.conditions[median.sw.conditions$med_S < 30,]$TA.treat <- 27

median.sw.conditions = median.sw.conditions[median.sw.conditions$`Bucket#` != 7 | median.sw.conditions$`Bucket#` != 14,]

median = median.sw.conditions %>%
  group_by(`Bucket#`) %>%
  summarize(med.TA = mean(med_TA), med.S = mean(med_S), med.T = mean(med_T), med.pH = mean(med_pH))

par(mfrow = c(1,1), mar = c(4, 5, 1.5, 2))

a = round(mean(median[median$`Bucket#` == 1,]$med.TA,
         median[median$`Bucket#` == 12,]$med.TA),0)
b = round(mean(median[median$`Bucket#` == 8,]$med.TA,
         median[median$`Bucket#` == 3,]$med.TA),0)
c = round(mean(median[median$`Bucket#` == 13,]$med.TA,
         median[median$`Bucket#` == 11,]$med.TA),0)
d = round(mean(median[median$`Bucket#` == 6,]$med.TA,
         median[median$`Bucket#` == 2,]$med.TA),0)
e = round(mean(median[median$`Bucket#` == 9,]$med.TA,
         median[median$`Bucket#` == 4,]$med.TA),0)
f = round(mean(median[median$`Bucket#` == 10,]$med.TA,
         median[median$`Bucket#` == 5,]$med.TA),0)

```
for the supplementary table
```{r}
sw2 = median.sw.conditions[median.sw.conditions$`Bucket#` != 7 & median.sw.conditions$`Bucket#` != 14,]
sw2$T. = NA
sw2[sw2$`Bucket#` == 3 | sw2$`Bucket#` == 8,]$T. <- "T1"
sw2[sw2$`Bucket#` == 2 | sw2$`Bucket#` == 6,]$T. = "T2"
sw2[sw2$`Bucket#` == 10 | sw2$`Bucket#` == 5,]$T. = "T3"


sw2[sw2$`Bucket#` == 1 | sw2$`Bucket#` == 12,]$T. = "t1"
sw2[sw2$`Bucket#` == 11 | sw2$`Bucket#` == 13,]$T. = "t2"
sw2[sw2$`Bucket#` == 4 | sw2$`Bucket#` == 9,]$T. = "t3"

sw2$Om = (carb(flag = 8, var1 = sw2$med_pH, var2 = sw2$med_TA/10^6, T = sw2$med_T, S = sw2$med_S)$OmegaCalcite)
sw2$HCO3 = (carb(flag = 8, var1 = sw2$med_pH, var2 = sw2$med_TA/10^6, T = sw2$med_T, S = sw2$med_S)$HCO3)*10^6
sw2$CO3 = (carb(flag = 8, var1 = sw2$med_pH, var2 = sw2$med_TA/10^6, T = sw2$med_T, S = sw2$med_S)$CO3)*10^6
sw2$DIC = (carb(flag = 8, var1 = sw2$med_pH, var2 = sw2$med_TA/10^6, T = sw2$med_T, S = sw2$med_S)$DIC)*10^6
sw2$pCO2 = (carb(flag = 8, var1 = sw2$med_pH, var2 = sw2$med_TA/10^6, T = sw2$med_T, S = sw2$med_S)$pCO2)

#table of the summary stats with SE for each treatment
library(dplyr)
mean.sw2 <- sw2 %>%
  group_by(`Bucket#`) %>%
  summarize(aveTA = mean(med_TA),
              SETA = sd(med_TA)/sqrt(n()),
            ave_S = mean(med_S),
              SES = sd(med_S)/sqrt(n()),
            ave_pH = mean(med_pH),
              SEpH = sd(med_pH)/sqrt(n()),
            ave_T = mean(med_T),
              SET = sd(med_T)/sqrt(n()),
            ave_DIC = mean(DIC),
              SEDIC = sd(DIC)/sqrt(n()),
            ave_HCO3 = mean(HCO3),
              SEHCO3 = sd(HCO3)/sqrt(n()),
            ave_CO3 = mean(CO3),
              SECO3 = sd(CO3)/sqrt(n()),
            ave_Om = mean(Om),
              SEOm = sd(Om)/sqrt(n()),
            ave_pco2 = mean(pCO2),
              SEpco2 = sd(pCO2)/sqrt(n()),
            S.treat = NA, TA.treat = NA)
write.csv(mean.sw2, "Supp table SW param.csv")



```
now for the figures...
```{r}

############Total alkalinity monitoring
#making a color scale for alkalinity concentration?
rbPal = colorRampPalette(c("grey99","grey85","grey70","grey50","grey30","black"))

median.sw.conditions$col = rbPal(6)[as.numeric(cut(median.sw.conditions$med_TA,
breaks = c(0,a,b,c,d,e,3500)))]

plot(med_TA ~ as.Date(Date), 
     data = median.sw.conditions,
     pch = 19,
     type = "n",
     ylim = c(500,3500),
     las = 1,
     xlab = NA,
     ylab = NA,
     xaxt='n',
     bty = 'n',
     axes = F,
     xlim=c(as.Date("2022-08-02"),as.Date("2022-09-05")))
points(med_TA ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 34,], pch = 21, bg = col, cex = 1.25)
points(med_TA ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 27,], pch = 24, bg = col, cex = 1.25)
#average lines per treatment (ave of the two buckets)
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(a,a), lwd = 2, lty = 2, col = "grey30")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(b,b), lwd = 2, lty = 2, col = "grey30")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(c,c), lwd = 2, lty = 2, col = "grey30")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(d,d), lwd = 2, lty = 2, col = "grey30")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(e,e), lwd = 2, lty = 2, col = "grey30")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(f,f), lwd = 2, lty = 2, col = "grey30")
lines(x=c(as.Date("2022-08-01"),as.Date("2022-09-05")), y=c(500,500), lwd = 2)
x <- c(as.Date("2022-08-01"), as.Date("2022-09-05"))
y <- c(490,490)
# Add tick marks along the line
tick_positions <- c(as.Date("2022-08-01"),
                    as.Date("2022-08-08"),
                    as.Date("2022-08-15"),
                    as.Date("2022-08-22"),
                    as.Date("2022-08-29"),
                    as.Date("2022-09-05"))
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}
axis(side = 1, line = -0.5, at = c(as.Date("2022-08-05"), as.Date("2022-08-18"), as.Date("2022-08-30")), labels = c("Aug 03","Aug 18","Sept 02"), cex.axis = 1.15, tick = F)

axis(side = 1, line = 1, tick = F, at = as.Date("2022-08-18"), labels = "Date", cex.axis = 1.25)

lines(x=c(as.Date("2022-08-01"),as.Date("2022-08-01")), y=c(500,3500), lwd = 2)
y <- c(500, 3500)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(500, 1000,
                    1500, 2000,
                    2500, 3000,
                    3500)  # Adjust these to your desired positions
tick_length <- 100  # Adjust the tick length as needed
x = as.Date("2022-08-01")  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}
axis(side = 2, line = -0.75, tick = F, at = c(1000,2000,3000), labels = c("1000","2000","3000"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 3, tick = F, at = 2000, labels = 'Total alkalinity ', cex.axis = 1.15)
axis(side = 2, line = 1.5, tick = F, at = 2000, labels = expression(paste('(',mu,'mol kg'^-1,')')), cex.axis = 1.15)

# Create an empty plot (blank screen)
par(mar = c(1, 1, 1, 1))
plot(1, type = "n", xlab = "", ylab = "", xlim = c(0, 1), ylim = c(0, 1))
# Add legend for S treatment
legend("topleft", legend = unique(median.sw.conditions$S.treat), col = "black", pch = c(17,19), title = "Salinity", cex = 1.2, pt.cex = 2, bty = "n")

# Add legend for TA treatment
legend("center", legend = c(f, e, d, c, b, a),
       pt.bg = c("black",
                 "grey30",
                 "grey50",
                 "grey70",
                 "grey85",
                 "grey99"), pch = 22, title = "Average TA", cex = 1.1, pt.cex = 2, bty = "n")

############Temperature monitoring
par(mar = c(4, 5, 1.5, 2))
plot(med_T ~ as.Date(Date), 
     data = median.sw.conditions,
     pch = 18,
     col = "black",
     las = 1,
     xlab = NA,
     ylab = NA,
     xaxt='n',
     bty = 'n',
     axes = F,
     ylim = c(10,30),
     xlim=c(as.Date("2022-08-02"),as.Date("2022-09-05")))

points(med_T ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 34,], pch = 19, col = "black", cex = 1.25)
points(med_T ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 27,], pch = 17, col = "black", cex = 1.25)

lines(x=c(as.Date("2022-08-01"),as.Date("2022-09-05")), y=c(10,10), lwd = 2)
lines(x=c(as.Date("2022-08-01"),as.Date("2022-08-01")), y=c(10,23), lwd = 2)

y <- c(10,30)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(10,12,14,16,18,20)  # Adjust these to your desired positions
tick_length <- 10  # Adjust the tick length as needed
x = as.Date("2022-08-01")  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}

axis(side = 2, line = -0.5, tick = F, at = c(11,16,21), labels = c("10","15","20"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.5, tick = F, at = 16.5, labels = "Temperature (C)", cex.axis = 1.15)

y <- c(10,10)
# Add tick marks along the line
tick_positions <- c(as.Date("2022-08-01"),
                    as.Date("2022-08-08"),
                    as.Date("2022-08-15"),
                    as.Date("2022-08-22"),
                    as.Date("2022-08-29"),
                    as.Date("2022-09-05"))
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}
axis(side = 1, line = -0.5, at = c(as.Date("2022-08-05"), as.Date("2022-08-18"), as.Date("2022-08-30")), labels = c("Aug 03","Aug 18","Sept 02"), cex.axis = 1.15, tick = F)

axis(side = 1, line = 1, tick = F, at = as.Date("2022-08-18"), labels = "Date", cex.axis = 1.25)


############Salinity monitoring

plot(med_S ~ as.Date(Date), 
     data = median.sw.conditions,
     pch = 18,
     col = "black",
     las = 1,
     xlab = NA,
     ylab = NA,
     xaxt='n',
     bty = 'n',
     axes = F,
     ylim = c(24,36),
     xlim=c(as.Date("2022-08-02"),as.Date("2022-09-05")))

points(med_S ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 34,], pch = 19, col = "black", cex = 1.25)
points(med_S ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 27,], pch = 17, col = "black", cex = 1.25)

lines(x=c(as.Date("2022-08-01"),as.Date("2022-09-05")), y=c(24,24), lwd = 2)
lines(x=c(as.Date("2022-08-01"),as.Date("2022-08-01")), y=c(24,38), lwd = 2)

axis(side = 2, line = -0.5, tick = F, at = c(27,34), labels = c("27","34"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.5, tick = F, at = 29, labels = "Salinity", cex.axis = 1.15)

y <- c(24,36)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(25,27,29,31,33,35)  # Adjust these to your desired positions
tick_length <- 10  # Adjust the tick length as needed
x = as.Date("2022-08-01")  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}


y <- c(24,24)
# Add tick marks along the line
tick_positions <- c(as.Date("2022-08-01"),
                    as.Date("2022-08-08"),
                    as.Date("2022-08-15"),
                    as.Date("2022-08-22"),
                    as.Date("2022-08-29"),
                    as.Date("2022-09-05"))
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}
axis(side = 1, line = -0.5, at = c(as.Date("2022-08-05"), as.Date("2022-08-18"), as.Date("2022-08-30")), labels = c("Aug 03","Aug 18","Sept 02"), cex.axis = 1.15, tick = F)

axis(side = 1, line = 1, tick = F, at = as.Date("2022-08-18"), labels = "Date", cex.axis = 1.25)

```

###Figure 3: effect of TA on inc growth through time as S
plot of only the later time period? effect of TA and S separate? 
```{r}
  par(mar=c(3,5,3,5))
#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
plot(Diff_growth ~ jitter(med.ta,25), ylab = NA, xlab = NA, ylim = c(-25,40), frame.plot = F, axes = F, data = end, pch = 21, xlim = c(650,3000), bg = as.factor(end$sal.treat.x), type = "n")
lines(x= c(650,3000), y=c(-25,-25), lwd = 2)
lines(x= c(650,650), y=c(-25,45), lwd = 2)

x <- c(650,3000)
y <- c(-25,-25)
# Add tick marks along the line
tick_positions <- c(800,1200,1600,2000,2400,2800)
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}

axis(side = 1, line = -0.75, tick = F, at = c(800,1200,1600,2000,2400,2800), labels = c("800","1200","1600","2000","2400","2800"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 1800, labels = expression(paste("Total alkalinity (",mu,"mol kg"^-1,")")), cex.axis = 1.1)

axis(side = 2, line = -1, tick = F, at = c(-20, 0, 20, 40), labels = c("-20", "0", "20", "40"), cex.axis = 1.1, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 10, labels = 'Growth in shell area', cex.axis = 1.1)
axis(side = 2, line = 0.25, tick = F, at = 10, labels = expression(paste(' (mm'^2,')')), cex.axis = 1.1)

y <- c(25,45)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(-20,-10,0,10,20,30,40)  # Adjust these to your desired positions
tick_length <- 50  # Adjust the tick length as needed
x = 650  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}

points(Diff_growth ~ jitter(med.ta,25), data = end[end$sal.treat.x == "amb",], pch = 21, bg = "white")
points(Diff_growth ~ jitter(med.ta,25), data = end[end$sal.treat.x == "low",], pch = 24, bg = "grey50")


library(nlme)
mod = (lme(Diff_growth ~  factor(sal.treat.x) + SA.imp  + med.ta + dps + med.ta:factor(dps) + factor(sal.treat.x):factor(dps) + SA.imp:factor(dps), random = list(CV_ID = pdIdent(~1),bucket = pdIdent(~1)), data = inc))
summary(mod)

int.amb36 = mean(inc[inc$sal.treat.x == "amb" & inc$dps == 36,]$Diff_growth)
int.low36 = (int.amb36 + 1.857162)  
effect.TA36 = 0.003189  
 
SE.effTA = (0.000887)

lines(x = c(800,3000), y = c(int.amb36+(effect.TA36*800),int.amb36+(effect.TA36*3000)), lwd = 2, col = "black")

lines(x = c(800,3000), y =c(int.low36+(effect.TA36*800),int.low36+(effect.TA36*3000)), lwd = 2, col = "black")


lines(x = c(800,3000),
      y = c(int.amb36+(effect.TA36*800)+(SE.effTA*800),
            int.amb36+(effect.TA36*3000)+(SE.effTA*3000)),
      lwd = 2, col = "black",lty = 3)
lines(x = c(800,3000),
      y = c(int.amb36+(effect.TA36*800)-(SE.effTA*800),
            int.amb36+(effect.TA36*3000)-(SE.effTA*3000)),
      lwd = 2, col = "black",lty = 3)


lines(x = c(800,3000), 
      y = c(int.low36+(effect.TA36*800)+(SE.effTA*800),
            int.low36+(effect.TA36*3000)+(SE.effTA*3000)),
            lwd = 2, col = "black",lty = 3)
lines(x = c(800,3000), 
      y = c(int.low36+(effect.TA36*800)-(SE.effTA*800),
            int.low36+(effect.TA36*3000)-(SE.effTA*3000)),
            lwd = 2, col = "black",lty = 3)

legend(x=800 ,y=40, legend = c("S = 34","S = 27"), pt.bg  = c("white","grey50"), pch = c(21,24), bty = "n", title = "Salinity", pt.cex = 1.5)
legend(x=2000 ,y=-14, pch = NA, bty = "n", legend = "Later window", pt.cex = 1.5)

```
plot of only the early time period? effect of TA and S separate? 
```{r}
  par(mar=c(3,5,3,5))
#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
plot(Diff_growth ~ jitter(med.ta,25), ylab = NA, xlab = NA, ylim = c(-25,40), frame.plot = F, axes = F, data = inc[inc$dps == 18,], pch = 21, xlim = c(650,3000), bg = factor(sal.treat.x), type = "n")
lines(x= c(650,3000), y=c(-25,-25), lwd = 2)
lines(x= c(650,650), y=c(-25,45), lwd = 2)
x <- c(650,3000)
y <- c(-25,-25)
# Add tick marks along the line
tick_positions <- c(800,1200,1600,2000,2400,2800)
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}

y <- c(25,45)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(-20,-10,0,10,20,30,40)  # Adjust these to your desired positions
tick_length <- 50  # Adjust the tick length as needed
x = 650  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}

axis(side = 1, line = -0.75, tick = F, at = c(800,1200,1600,2000,2400,2800), labels = c("800","1200","1600","2000","2400","2800"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 1800, labels = expression(paste("Total alkalinity (",mu,"mol kg"^-1,")")), cex.axis = 1.1)

axis(side = 2, line = -1, tick = F, at = c(-20, 0, 20, 40), labels = c("-20", "0", "20", "40"), cex.axis = 1.1, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 10, labels = 'Growth in shell area', cex.axis = 1.1)
axis(side = 2, line = 0.25, tick = F, at = 10, labels = expression(paste(' (mm'^2,')')), cex.axis = 1.1)

points(Diff_growth ~ jitter(med.ta,25), data = inc[inc$sal.treat.x == "amb" & inc$dps == 18,], pch = 21, bg = "white")
points(Diff_growth ~ jitter(med.ta,25), data = inc[inc$sal.treat.x == "low"& inc$dps == 18,], pch = 24, bg = "grey50")

mod = (lme(Diff_growth ~  factor(sal.treat.x) + SA.imp  + med.ta + dps + med.ta:factor(dps) + factor(sal.treat.x):factor(dps) + SA.imp:factor(dps), random = list(CV_ID = pdIdent(~1),bucket = pdIdent(~1)), data = inc))
summary(mod)

int.amb18 = mean(inc[inc$sal.treat.x == "amb" & inc$dps == 18,]$Diff_growth)
int.low18 = (int.amb18 + 0.713651)  
effect.TA18 = 0
SE.effTA = (0.0011)

lines(x = c(800,3000), y = c(int.amb18+(effect.TA18*800),int.amb18+(effect.TA18*3000)), lwd = 2, col = "black")

lines(x = c(800,3000), y =c(int.low18+(effect.TA18*800),int.low18+(effect.TA18*3000)), lwd = 2, col = "black")


lines(x = c(800,3000),
      y = c(int.amb18+(effect.TA18*800)+(SE.effTA*800),
            int.amb18+(effect.TA18*3000)+(SE.effTA*3000)),
      lwd = 2, col = "black",lty = 3)
lines(x = c(800,3000),
      y = c(int.amb18+(effect.TA18*800)-(SE.effTA*800),
            int.amb18+(effect.TA18*3000)-(SE.effTA*3000)),
      lwd = 2, col = "black",lty = 3)


lines(x = c(800,3000), 
      y = c(int.low18+(effect.TA18*800)+(SE.effTA*800),
            int.low18+(effect.TA18*3000)+(SE.effTA*3000)),
            lwd = 2, col = "black",lty = 3)
lines(x = c(800,3000), 
      y = c(int.low18+(effect.TA18*800)-(SE.effTA*800),
            int.low18+(effect.TA18*3000)-(SE.effTA*3000)),
            lwd = 2, col = "black",lty = 3)

legend(x=1200 ,y=50, legend = c("S = 34","S = 27"), pt.bg = c("white","grey50"), pch = c(21,24), bty = "n", title = "Salinity", pt.cex = 1.5)
legend(x=2000 ,y=-14, pch = NA, bty = "n", legend = "Earlier window", pt.cex = 1.5)

```
###Figure 4: effect of SA (and TA) on growth by dps
effect of size on growth
```{r}
inc$pch.S = NA
inc[inc$sal.treat.x == "amb",]$pch.S <- 21 
inc[inc$sal.treat.x == "low",]$pch.S <- 24

mod.final = (lme(Diff_growth ~  factor(sal.treat.x) + SA.imp  + med.ta + dps + med.ta:factor(dps) + factor(sal.treat.x):factor(dps) + SA.imp:dps, random = list(CV_ID = pdIdent(~1),bucket = pdIdent(~1)), data = inc))

#making a color scale for alkalinity concentration?
n =6
#making a color scale for alkalinity concentration?
rbPal = colorRampPalette(c("grey99","grey85","grey70","grey50","grey30","black"))

inc$col = rbPal(6)[as.numeric(cut(inc$med.ta,
breaks = c(400,a,b,c,d,e,3500)))]

#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
plot(Diff_growth ~ SA.imp, ylab = NA, xlab = NA, ylim = c(-25,40), frame.plot = F, axes = F, data = inc, pch = 21, xlim = c(40,300), bg = inc$col, type = "n")

points(Diff_growth ~ SA.imp,data = inc[inc$dps == 18,], pch = inc[inc$dps == 18,]$pch.S, bg = inc[inc$dps == 18,]$col)

lines(x= c(40,315), y=c(-25,-25), lwd = 2)
lines(x= c(40,40), y=c(-25,50), lwd = 2)

x <- c(40,300)
y <- c(-25,-25)
# Add tick marks along the line
tick_positions <- c(50,100,150,200,250,300)
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}

y <- c(-25,45)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(-20,-10,0,10,20,30,40)  # Adjust these to your desired positions
tick_length <- 5  # Adjust the tick length as needed
x = 40  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}

axis(side = 2, line = -1, tick = F, at = c(-20, 0, 20, 40), labels = c("-20", "0", "20", "40"), cex.axis = 1.1, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 10, labels = 'Growth in shell area', cex.axis = 1.1)
axis(side = 2, line = 0.25, tick = F, at = 10, labels = expression(paste(' (mm'^2,')')), cex.axis = 1.1)

axis(side = 1, line = -0.75, tick = F, at = c(50,100,150,200,250,300), labels = c("50","100","150","200","250","300"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 175, labels = expression(paste("Size at start of window (mm"^2,")")), cex.axis = 1.1)

mod = (lme(Diff_growth ~  factor(sal.treat.x) + SA.imp  + med.ta + dps + med.ta:factor(dps) + factor(sal.treat.x):factor(dps) + SA.imp:factor(dps), random = list(CV_ID = pdIdent(~1),bucket = pdIdent(~1)), data = inc))
summary(mod)

int.amb18 = 13.674002    
int.amb36 = (13.674002 - 0.491765+1.857162  )    
effect.SA18 = 0.043209  
  effect.SA36 = -0.057029   
SE.effSA18 = 0.010359  
SE.effSA36 = 0.013965 

lines(x = c(50,300), y = c(int.amb18+(effect.SA18*40),int.amb18+(effect.SA18*300)), lwd = 2, col = "black")

lines(x = c(50,300),
      y = c(int.amb18+(effect.SA18*50)+(SE.effSA18*50),
            int.amb18+(effect.SA18*300)+(SE.effSA18*800)),
      lwd = 2, col = "black",lty = 3)
lines(x = c(50,300),
      y = c(int.amb18+(effect.SA18*50)-(SE.effSA18*50),
            int.amb18+(effect.SA18*300)-(SE.effSA18*300)),
      lwd = 2, col = "black",lty = 3)

#legend(y=20 ,x=250, legend = c("S = 34","S = 27"), pt.bg  = c("black","black"), pch = c(21,24), bty = "n", title = "Salinity", pt.cex = 1.5)
legend(x=200 ,y=-15, pch = NA, bty = "n", legend = "Earlier window", pt.cex = 1.5)

# Set graphical parameters for the legend

plot(Diff_growth ~ SA.imp, ylab = NA, xlab = NA, ylim = c(-25,40), frame.plot = F, axes = F, data = inc, pch = 21, xlim = c(40,300), bg = inc$col, type = "n")
points(Diff_growth ~ SA.imp,data = inc[inc$dps == 36,], pch = inc[inc$dps == 36,]$pch.S, bg = inc[inc$dps == 36,]$col)

lines(x= c(40,315), y=c(-25,-25), lwd = 2)
lines(x= c(40,40), y=c(-25,50), lwd = 2)

x <- c(40,300)
y <- c(-25,-25)
# Add tick marks along the line
tick_positions <- c(50,100,150,200,250,300)
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}

y <- c(-25,45)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(-20,-10,0,10,20,30,40)  # Adjust these to your desired positions
tick_length <- 5  # Adjust the tick length as needed
x = 40  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}

axis(side = 2, line = -1, tick = F, at = c(-20, 0, 20, 40), labels = c("-20", "0", "20", "40"), cex.axis = 1.1, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 10, labels = 'Growth in shell area', cex.axis = 1.1)
axis(side = 2, line = 0.25, tick = F, at = 10, labels = expression(paste(' (mm'^2,')')), cex.axis = 1.1)

axis(side = 1, line = -0.75, tick = F, at = c(50,100,150,200,250,300), labels = c("50","100","150","200","250","300"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 175, labels = expression(paste("Size at start of window (mm"^2,")")), cex.axis = 1.1)


lines(x = c(50,300), y =c(int.amb36+(effect.SA36*50),int.amb36+(effect.SA36*300)), lwd = 2, col = "black")

lines(x = c(50,300),
      y = c(int.amb36+(effect.SA36*50)+(SE.effSA36*50),
            int.amb36+(effect.SA36*300)+(SE.effSA36*300)),
      lwd = 2, col = "black",lty = 3)
lines(x = c(50,300),
      y = c(int.amb36+(effect.SA36*50)-(SE.effSA36*50),
            int.amb36+(effect.SA36*300)-(SE.effSA36*300)),
      lwd = 2, col = "black",lty = 3)

#legend(y=45 ,x=215, legend = c("S = 34","S = 27"), pt.bg  = c("black","black"), pch = c(21,24), bty = "n", title = "Salinity", pt.cex = 1.5)
legend(x=200 ,y=-15, pch = NA, bty = "n", legend = "Later window", pt.cex = 1.5)

####separate image for the color scale for both mc and mg net calcification rate
par(mfrow = c(1,1))
legend_image=as.raster(matrix(rbPal(6),nrow=1))
plot(1:10,1:10,type='n',axes=FALSE,xlab='',ylab='')
rasterImage(legend_image,xleft=4.5,ybottom=4,xright=8,ytop=4.75, angle = 90)
text(y=seq(4.25,9.25,l=6),x=5.15,labels=round(c(a,b,c,d,e,f),0),cex=1)
calclabel = expression(paste('Average TA'))
calclabel2 = expression(paste('(',mu,'mol kg'^-1,')'))
text(y= 6.5,x= 3,labels=calclabel,pos=3,adj=0.5, srt = 90, cex = 1.1)
text(y= 6.5,x= 3.75,labels=calclabel2,pos=3,adj=0.5, srt = 90, cex = 1.1)


```
###Figure NA: effect of TA on growth by dps
plot of both time periods; uses slopes calc from above
```{r}
inc$col = NA
inc[inc$dps == 18,]$col = "grey10"
inc[inc$dps == 36,]$col = "grey60"

#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
plot(Diff_growth ~ jitter(med.ta,25), ylab = NA, xlab = NA, ylim = c(-25,40), frame.plot = F, axes = F, data = inc, pch = 21, xlim = c(650,3000), bg = inc$col, type = "n")
points(Diff_growth ~ jitter(med.ta,25),data = inc[inc$dps == 18,], pch = 21, bg = "grey10")
points(Diff_growth ~ jitter(med.ta,25),data = inc[inc$dps == 36,], pch = 24, bg = "grey60")

lines(x= c(650,3000), y=c(-25,-25), lwd = 2)
lines(x= c(650,650), y=c(-25,40), lwd = 2)

axis(side = 1, line = -0.9, tick = F, at = c(800,1200,1600,2000,2400,2800), labels = c("800","1200","1600","2000","2400","2800"), cex.axis = 1.1)
axis(side = 1, line = 0.5, tick = F, at = 1800, labels = expression(paste("Total alkalinity (",mu,"mol kg"^-1,")")), cex.axis = 1.1)

axis(side = 2, line = -1.5, tick = F, at = c(-20, 0, 20, 40), labels = c("-20", "0", "20", "40"), cex.axis = 1.1, las = 1)
axis(side = 2, line = 1.5, tick = F, at = 10, labels = 'Growth in shell area', cex.axis = 1.1)
axis(side = 2, line = 0, tick = F, at = 10, labels = expression(paste(' (mm'^2,'per window)')), cex.axis = 1.1)


mod = (lme(Diff_growth ~  factor(sal.treat.x) + SA.imp  + med.ta + dps + med.ta:factor(dps) + factor(sal.treat.x):factor(dps) + SA.imp:factor(dps), random = list(CV_ID = pdIdent(~1),bucket = pdIdent(~1)), data = inc))
summary(mod)

int.amb18 = 13.674002    
int.36 = (13.674002 - 0.491765)    
effect.TA18 = 0
  effect.TA36 = 0.002738   
SE.slope18 = 0.000683 
SE.slope36 = 0.000962

lines(x = c(800,3000), y = c(int.amb18+(effect.TA18*800),int.amb18+(effect.TA18*3000)), lwd = 2, col = "black")

lines(x = c(800,3000), y =c(int.amb36+(effect.TA36*800),int.amb36+(effect.TA36*3000)), lwd = 2, col = "grey30")

lines(x = c(800,3000),
      y = c(int.amb18+(effect.TA18*800)+(SE.effTA*800),
            int.amb18+(effect.TA18*3000)+(SE.effTA*3000)),
      lwd = 2, col = "black",lty = 3)
lines(x = c(800,3000),
      y = c(int.amb18+(effect.TA18*800)-(SE.effTA*800),
            int.amb18+(effect.TA18*3000)-(SE.effTA*3000)),
      lwd = 2, col = "black",lty = 3)


lines(x = c(800,3000),
      y = c(int.amb36+(effect.TA36*800)+(SE.effTA*800),
            int.amb36+(effect.TA36*3000)+(SE.effTA*3000)),
      lwd = 2, col = "grey30",lty = 3)
lines(x = c(800,3000),
      y = c(int.amb36+(effect.TA36*800)-(SE.effTA*800),
            int.amb36+(effect.TA36*3000)-(SE.effTA*3000)),
      lwd = 2, col = "grey30",lty = 3)

# Set graphical parameters for the legend

legend(x=1200 ,y=55, legend = c("early","later"), pt.bg = c("grey10","grey60"), pch = c(21,24), bty = "n", title = "Exposure window", pt.cex = 1.5)


```
###Figure 5: effect of TA and S on overall shell growth
```{r}
  par(mar=c(3,5,3,5))
end$col = NA
end[end$sal.treat.x == "amb",]$col = "white"
end[end$sal.treat.x == "low",]$col = "grey50"
summary(mod)
#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
plot(Net_growth ~ jitter(med.ta,25), ylab = NA, xlab = NA, ylim = c(-25,70), frame.plot = F, axes = F, data = end, pch = 21, xlim = c(650,3000), bg = end$col, type = "n")
points(Net_growth ~ jitter(med.ta,25),data = end[end$sal.treat.x == "amb",], pch = 21, bg = "white")
points(Net_growth ~ jitter(med.ta,25),data = end[end$sal.treat.x == "low",], pch = 24, bg = "grey50")

lines(x= c(650,3000), y=c(-25,-25), lwd = 2)
lines(x= c(650,650), y=c(-25,70), lwd = 2)

x <- c(650,3000)
y <- c(-25,-25)
# Add tick marks along the line
tick_positions <- c(800,1200,1600,2000,2400,2800)
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}

y <- c(25,45)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(-20,-10,0,10,20,30,40,50,60)  # Adjust these to your desired positions
tick_length <- 50  # Adjust the tick length as needed
x = 650  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}

axis(side = 1, line = -0.75, tick = F, at = c(800,1200,1600,2000,2400,2800), labels = c("800","1200","1600","2000","2400","2800"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 1800, labels = expression(paste("Total alkalinity (",mu,"mol kg"^-1,")")), cex.axis = 1.1)

axis(side = 2, line = -1, tick = F, at = c(-20, 0, 20, 40,60), labels = c("-20", "0", "20", "40","60"), cex.axis = 1.1, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 20, labels = 'Overall growth in shell area', cex.axis = 1.1)
axis(side = 2, line = 0.25, tick = F, at = 20, labels = expression(paste(' (mm'^2,')')), cex.axis = 1.1)


mod = (lme(Net_growth ~  factor(sal.treat.x) + SA.start  + med.ta, random = ~1|bucket, data = end))
summary(mod)

int.amb = -3.870880   
int.low = (-3.870880 + 3.726026)
  effect.TA36 = 0.004167     
SE.effTA = 0.002590

lines(x = c(800,3000), y = c(int.amb+(effect.TA36*3000),int.amb+(effect.TA36*3000)), lwd = 2, col = "black")

lines(x = c(800,3000), y =c(int.low+(effect.TA36*3000),int.low+(effect.TA36*3000)), lwd = 2, col = "black")


lines(x = c(800,3000),
      y = c(int.amb+(effect.TA36*3000)+(SE.effTA*800),
            int.amb+(effect.TA36*3000)+(SE.effTA*3000)),
      lwd = 2, col = "black",lty = 3)
lines(x = c(800,3000),
      y = c(int.amb+(effect.TA36*3000)-(SE.effTA*800),
            int.amb+(effect.TA36*3000)-(SE.effTA*3000)),
      lwd = 2, col = "black",lty = 3)


lines(x = c(800,3000),
      y = c(int.low+(effect.TA36*800)+(SE.effTA*800)+ 3.726026,
            int.low+(effect.TA36*3000)+(SE.effTA*3000))+ 3.726026,
      lwd = 2, col = "black",lty = 3)
lines(x = c(800,3000),
      y = c(int.low+(effect.TA36*800)-(SE.effTA*800)+ 3.726026,
            int.low+(effect.TA36*3000)-(SE.effTA*3000))+ 3.726026,
      lwd = 2, col = "black",lty = 3)

# Set graphical parameters for the legend

#legend(x=1200 ,y=70, legend = c("S = 34","S = 27"), pt.bg = c("black","grey30"), pch = c(21,24), bty = "n", title = "Salinity", pt.cex = 1.5)


```


###Figure 6 A & B: effect of TA and S (and size on net growth, thickness, and CI)
```{r}
  par(mar=c(3,4.75,3,4.5))
#net thickness
mean.thick = mean(end$thick.mgmm2)
slope.ta = 7.126e-05*300
SE.slopeta = 3.200e-05*300

plot(thick.mgmm2 ~ med.ta, ylab = NA, xlab = NA, ylim = c(0.75,4.5), frame.plot = F, axes = F, data = end, pch = 21, xlim = c(500,3000), bg = end$col, type = "n")
lines(x= c(500,3000), y=c(0.75,0.75), lwd = 2)
lines(x= c(500,500), y=c(0.75,4.5), lwd = 2)

points(thick.mgmm2 ~ med.ta, data = end[end$sal.treat.x == "amb",], pch = 21, bg = end[end$sal.treat.x == "amb",]$col)
points(thick.mgmm2 ~ med.ta, data = end[end$sal.treat.x == "low",], pch = 24, bg = end[end$sal.treat.x == "low",]$col)


x <- c(500,3000)
y <- c(0.75,4.5)
# Add tick marks along the line
tick_positions <- c(800,1200,1600,2000,2400,2800)
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}

y <- c(0.75,4.5)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(1,1.5,2,2.5,3,3.5,4,4.5)  # Adjust these to your desired positions
tick_length <- 50  # Adjust the tick length as needed
x = 500  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}
axis(side = 1, line = -0.75, tick = F, at = c(800,1200,1600,2000,2400,2800), labels = c("800","1200","1600","2000","2400","2800"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 1800, labels = expression(paste("Total alkalinity (",mu,"mol kg"^-1,")")), cex.axis = 1.1)

axis(side = 2, line = -1, tick = F, at = c(1,2,3,4), labels = c("1.0","2.0","3.0","4.0"), cex.axis = 1.1, las = 1)
axis(side = 2, line = 2.5, tick = F, at = 2.5, labels = 'Shell thickness', cex.axis = 1.1)
axis(side = 2, line = 1, tick = F, at = 2.5, labels = expression(paste(' (mg'^2,' mm'^-2,')')), cex.axis = 1.1)

#condition index

plot(CI ~ med.ta, ylab = NA, xlab = NA, frame.plot = F, axes = F, data = end, pch = 21, xlim = c(500,3000), bg = end$col, ylim = c(-0.001,0.03), type = "n")
lines(x= c(500,3000), y=c(-0.001,-0.001), lwd = 2)
lines(x= c(500,500), y=c(-0.001,0.04), lwd = 2)

points(CI ~ med.ta, data = end[end$sal.treat.x == "amb",], pch = 21, bg = end[end$sal.treat.x == "amb",]$col)
points(CI ~ med.ta, data = end[end$sal.treat.x == "low",], pch = 24, bg = end[end$sal.treat.x == "low",]$col)


x <- c(650,3000)
y <- c(-0.001,3)
# Add tick marks along the line
tick_positions <- c(800,1200,1600,2000,2400,2800)
tick_length <- 100  # Adjust the tick length as needed
for (tick in tick_positions) {
  segments(tick, min(y), tick, min(y) - tick_length, lwd = 2)
}

y <- c(25,45)  # Adjust the y-values to fit your data
# Add tick marks along the Y-axis
tick_positions <- c(0,0.005,0.01,0.015,0.02,0.025,0.03)  # Adjust these to your desired positions
tick_length <- 50  # Adjust the tick length as needed
x = 500  # X-coordinate for the tick marks
for (tick in tick_positions) {
  segments(min(x), tick, min(x) - tick_length, tick, lwd = 2)
}
axis(side = 1, line = -0.75, tick = F, at = c(800,1200,1600,2000,2400,2800), labels = c("800","1200","1600","2000","2400","2800"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 1800, labels = expression(paste("Total alkalinity (",mu,"mol kg"^-1,")")), cex.axis = 1.1)

axis(side = 2, line = -1, tick = F, at = c(0,0.01,0.02,0.03), labels = c("0","0.01","0.02","0.03"), cex.axis = 1.1, las = 1)
axis(side = 2, line = 2.5, tick = F, at = 0.015, labels = 'Condition index', cex.axis = 1.1)
axis(side = 2, line = 1, tick = F, at = 0.015, labels = expression(paste(' (mg'^2,' mg'^-2,')')), cex.axis = 1.1)
```

OLD MODELS AND FIGURES
############################################
         MODEL 1: How does the effect of [TA] on shell growth (surface area) at ambient and lower salinity change over time?
incremental split on shell growth? 
AMB SALINITY
```{r}

###   AMB SALINITY

#MEETING ASSUMPTIONS:

#model with all predictors. 
mod.18amb <- lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 18 &
                          inc$sal.treat.x == "amb",]),
                na.action=na.omit)

mod.18amb.w <- lme(incr_growth.d ~ SA.imp + (T.),            random  = ~1 | bucket, data= (inc[inc$dps == 18 &           inc$sal.treat.x == "amb",]), na.action=na.omit, weights = varIdent(form = ~ 1 | T.))  # Use the inverse of squared residuals as weights)

mod.36amb <- lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 36 &
                          inc$sal.treat.x == "amb",]),
                na.action=na.omit)
mod.36amb.w <- lme(incr_growth.d ~ SA.imp + (T.), random  = ~1 | bucket, data= (inc[inc$dps == 36 & inc$sal.treat.x == "amb",]), na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights)

summary(mod.18amb)
summary(mod.36amb.w)


#compare the two models; if they are sig, then the weights sign improved the model fit!
anova(mod.18amb, mod.18amb.w) #DOES NOT SIG IMPROVE
anova(mod.36amb, mod.36amb.w) #DOES SIG IMPROVE

# Residuals vs. Fitted Values
plot(mod.18amb)
plot(mod.36amb.w)

# Normality of Residuals

qqnorm(resid(mod.18amb))
qqline(resid(mod.18amb))

qqnorm(resid(mod.36amb.w))
qqline(resid(mod.36amb.w))

# Homoscedasticity of Residuals
plot(resid(mod.18amb) ~ fitted(mod.18amb))
plot(resid(mod.36amb.w) ~ fitted(mod.36amb.w))

#Independence: added in bucket as a random intercept

# Fit the full model with the random effect
mod.full <- lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 18 &
                          inc$sal.treat.x == "amb",]),
                na.action=na.omit)

# Fit the null model without the random effect
mod.null <- gls(incr_growth.d ~ SA.imp +
                (T.),
                data= (inc[inc$dps == 18 &
                          inc$sal.treat.x == "amb",]),
                na.action=na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

mod.full <- lm(incr_growth.d ~ SA.imp + (T.), data= 
            (inc[inc$dps == 18 & inc$sal.treat.x == "amb",]), 
            na.action=na.omit)
mod.size <- lm(incr_growth.d ~ (T.), data= (inc[inc$dps == 18 &
            inc$sal.treat.x == "amb",]), na.action=na.omit)

#for table: 
anova(mod.full, mod.size)    #effect of Size

# Fit the full model with the random effect
mod.full <- lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 36 &
                          inc$sal.treat.x == "amb",]),
                na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

# Fit the null model without the random effect
mod.null <- gls(incr_growth.d ~ SA.imp +
                (T.),
                data= (inc[inc$dps == 36 &
                          inc$sal.treat.x == "amb",]),
                na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

mod.full <- lm(incr_growth.d ~ SA.imp + (T.), data= 
            (inc[inc$dps == 36 & inc$sal.treat.x == "amb",]), 
            na.action=na.omit)
mod.size <- lm(incr_growth.d ~ (T.), data= (inc[inc$dps == 36 &
            inc$sal.treat.x == "amb",]), na.action=na.omit)

#for table: 
anova(mod.full, mod.size)    #effect of Size

#FINAL MODEL
mod.final18 = lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 18 &
                          inc$sal.treat.x == "amb",]))

mod.final36 = lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 36 &
                          inc$sal.treat.x == "amb",]), weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

summary(mod.final18)
summary(mod.final36)

library(MuMIn)
r.squaredGLMM(object = mod.final18, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

r.squaredGLMM(object = mod.final36, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

boxplot(incr_growth.d ~ T., data = (inc[inc$dps == 18 &
                             inc$sal.treat.x == "amb",]),
                na.action=na.omit, outline = F)

boxplot(incr_growth.d ~ T., data = (inc[inc$dps == 36 &
                             inc$sal.treat.x == "amb",]),
                na.action=na.omit, outline = F)

```
LOW SALINITY
```{r}

###   LOW SALINITY

#MEETING ASSUMPTIONS:

#model with all predictors. 
mod.18low <- lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 18 &
                          inc$sal.treat.x == "low",]),
                na.action=na.omit)

mod.18low.w <- lme(incr_growth.d ~ SA.imp + (T.),            random  = ~1 | bucket, data= (inc[inc$dps == 18 &           inc$sal.treat.x == "low",]), na.action=na.omit, weights = varIdent(form = ~ 1 | T.))  # Use the inverse of squared residuals as weights)

mod.36low <- lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 36 &
                          inc$sal.treat.x == "low",]),
                na.action=na.omit)
mod.36low.w <- lme(incr_growth.d ~ SA.imp + (T.), random  = ~1 | bucket, data= (inc[inc$dps == 36 & inc$sal.treat.x == "low",]), na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights)

summary(mod.18low)
summary(mod.36low)


#compare the two models; if they are sig, then the weights sign improved the model fit!
anova(mod.18low, mod.18low.w) #DOES  SIG IMPROVE
anova(mod.36low, mod.36low.w) #DOES SIG IMPROVE

# Residuals vs. Fitted Values
plot(mod.18low.w)
plot(mod.36low.w)

# Normality of Residuals

qqnorm(resid(mod.18low.w))
qqline(resid(mod.18low.w))

qqnorm(resid(mod.36low.w))
qqline(resid(mod.36low.w))

# Homoscedasticity of Residuals
plot(resid(mod.18low.w) ~ fitted(mod.18low.w))
plot(resid(mod.36low.w) ~ fitted(mod.36low.w))


#Independence: added in bucket as a random intercept

#KEEP THE RANDOM EFFECT. 

# Fit the full model with the random effect
mod.full <- lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 18 &
                          inc$sal.treat.x == "low",]),
                na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

# Fit the null model without the random effect
mod.null <- gls(incr_growth.d ~ SA.imp +
                (T.),
                data= (inc[inc$dps == 18 &
                          inc$sal.treat.x == "low",]),
                na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

mod.full <- lm(incr_growth.d ~ SA.imp + (T.), data= 
            (inc[inc$dps == 18 & inc$sal.treat.x == "low",]), 
            na.action=na.omit)
mod.size <- lm(incr_growth.d ~ (T.), data= (inc[inc$dps == 18 &
            inc$sal.treat.x == "low",]), na.action=na.omit)

#for table: 
anova(mod.full, mod.size)    #effect of Size

# Fit the full model with the random effect
mod.full <- lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 36 &
                          inc$sal.treat.x == "low",]),
                na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

# Fit the null model without the random effect
mod.null <- gls(incr_growth.d ~ SA.imp +
                (T.),
                data= (inc[inc$dps == 36 &
                          inc$sal.treat.x == "low",]),
                na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

mod.full <- lm(incr_growth.d ~ SA.imp + (T.), data= 
            (inc[inc$dps == 36 & inc$sal.treat.x == "low",]), 
            na.action=na.omit)
mod.size <- lm(incr_growth.d ~ (T.), data= (inc[inc$dps == 36 &
            inc$sal.treat.x == "low",]), na.action=na.omit)

#for table: 
anova(mod.full, mod.size)    #effect of Size

#FINAL MODEL
mod.final18 = lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 18 &
                          inc$sal.treat.x == "low",]),
                na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

mod.final36 = lme(incr_growth.d ~ SA.imp +
                (T.),
                random  = ~1 | bucket,
                data= (inc[inc$dps == 36 &
                          inc$sal.treat.x == "low",]),
                na.action=na.omit, weights = varIdent(form = ~1 | T.))  # Use the inverse of squared residuals as weights))

summary(mod.final18)
summary(mod.final36)

#post hoc test to see which factors differ from one another: 
library(nlme)
library(lsmeans)
library(multcomp)

emm <- lsmeans(mod.final36, specs = "T.")
# Pairwise comparisons of factor levels for 'TA.treat.x'
posthoc <- pairs(emm)
#summary(posthoc)
#x, xy, y

library(MuMIn)
r.squaredGLMM(object = mod.final18, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

r.squaredGLMM(object = mod.final36, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

boxplot(incr_growth.d ~ T., data = (inc[inc$dps == 18 &
                             inc$sal.treat.x == "low",]),
                na.action=na.omit, outline = F)

boxplot(incr_growth.d ~ T., data = (inc[inc$dps == 36 &
                             inc$sal.treat.x == "low",]),
                na.action=na.omit, outline = F)

```
        MODEL 2:  What is the effect overall effect of [TA] on shell growth (thickness and surface area) at ambient and lower salinity?
###ambient salinity
on the shell thickness and condition index tradeoffs
```{r}

###   AMB SALINITY

#MEETING ASSUMPTIONS:

#model with all predictors vs one with weighting. 
mod.t.amb <- lme(thick.mgmm2 ~ (T.),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit)

mod.t.amb.w <- lme(thick.mgmm2 ~ (T.),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

mod.ci.amb <- lme(CI ~ (T.),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit)
mod.ci.amb.w <- lme(CI ~ (T.),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

#compare the two models; if they are sig, then the weights sign improved the model fit!
anova(mod.t.amb, mod.t.amb.w) #DOES  SIG IMPROVE
anova(mod.ci.amb, mod.ci.amb.w) #DOES  IMPROVE

# Residuals vs. Fitted Values
plot(mod.t.amb.w)
plot(mod.ci.amb.w)

# Normality of Residuals

qqnorm(resid(mod.t.amb.w))
qqline(resid(mod.t.amb.w))

qqnorm(resid(mod.ci.amb.w))
qqline(resid(mod.ci.amb.w))

# Homoscedasticity of Residuals
plot(resid(mod.t.amb.w) ~ fitted(mod.t.amb.w))
plot(resid(mod.ci.amb.w) ~ fitted(mod.ci.amb.w))

#Independence: added in bucket as a random intercept

# Fit the full model with the random effect
mod.full <- lme(thick.mgmm2 ~ (T.),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

# Fit the null model without the random effect
mod.null <- gls(thick.mgmm2 ~ (T.),
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))
# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

# Fit the full model with the random effect
mod.full <- lme(CI ~ (T.),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

# Fit the null model without the random effect
mod.null <- gls(CI ~ (T.),
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE



#FINAL MODEL
mod.finalthick = lme(thick.mgmm2 ~ (T.),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))
mod.finalci = lme(CI ~ (T.),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

summary(mod.finalthick)
summary(mod.finalci)

library(MuMIn)
r.squaredGLMM(object = mod.finalthick, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

r.squaredGLMM(object = mod.finalci, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```
on shell area growth; NO DIFFERENCE by TA, difference based on starting area size
```{r}
#quick look at the effect of TA (vs omega?)
boxplot(amb.S$Net_growth.d ~ as.factor(round(amb.S$med.ta,-3)))
boxplot(amb.S$Net_growth.d ~ as.factor(round(amb.S$med.OmC,0)))

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages
#testing variance heterskedasticity was done using a Bruesch-Pagan test https://www.statology.org/breusch-pagan-test-r/
library(nlme)

#transforming the data did not work and so instead I opted to apply weighted variance within the model that is equal to the inverse of the variance in each group (smaller variance gives larger weight within the SEs of the model )
#amb.S$Net_growth.d.TRANS = as.numeric(sqrt(amb.S$Net_growth.d+1))


#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start +
                factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit)

# Calculate weights based on squared residuals (variance of the error terms)
mod.full.w <- lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random = ~1 | bucket,
                data = (amb.S),
                weights = varIdent(form = ~ 1 | TA.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
anova(mod.full, mod.full.w)

#it is an improved fit! Good to go.

# Residuals vs. Fitted Values
plot(mod.full.w)

# Normality of Residuals
qqnorm(resid(mod.full.w))
qqline(resid(mod.full.w))

# Homoscedasticity of Residuals
plot(resid(mod.full.w) ~ fitted(mod.full.w))


#Independence: added in bucket as a random intercept

#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random = ~1 | bucket,
                data = (amb.S),
                weights = varIdent(form = ~ 1 | TA.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)


summary(mod.full)

#Normality: looking for Gaussian distribution
hist(resid(mod.full)) #looks okay!
plot(resid(mod.full) ~ amb.S$Net_growth.d)
plot(mod.full) #std resid vs fitted values looks okay!

#KEEP THE RANDOM EFFECT. 

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(Net_growth.d ~ SA.start + factor(TA.treat.x), random = ~1|bucket,
                 data = amb.S,
                 na.action = na.omit)

# Fit the null model without the random effect
mod.null <- gls(Net_growth.d ~ SA.start + factor(TA.treat.x),
                 data = amb.S,
                 na.action = na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

#effect of continuous predictors

mod.full <- lmer(Net_growth.d ~ SA.start + factor(TA.treat.x) + (1 | bucket), data = amb.S, na.action = na.omit)

  mod.sa = lmer(Net_growth.d ~ factor(TA.treat.x) + (1 | bucket), data = amb.S, na.action = na.omit)

#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 25.82, p = 3.749e-07

#FINAL MODEL
mod.final = lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random = ~1 | bucket,
                data = (amb.S),
                weights = varIdent(form = ~ 1 | TA.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
summary(mod.final)

r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```
###low salinity
on the shell thickness and condition index tradeoffs
```{r}

###   LOW SALINITY

#MEETING ASSUMPTIONS:

#model with all predictors vs one with weighting. 
mod.t.low <- lme(thick.mgmm2 ~ (T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit)

mod.t.low.w <- lme(thick.mgmm2 ~ (T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

mod.ci.low <- lme(CI ~ (T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit)
mod.ci.low.w <- lme(CI ~ (T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

#compare the two models; if they are sig, then the weights sign improved the model fit!
anova(mod.t.low, mod.t.low.w) #DOES  SIG IMPROVE
anova(mod.ci.low, mod.ci.low.w) #DOES NOT IMPROVE

# Residuals vs. Fitted Values
plot(mod.t.low.w)
plot(mod.ci.low)

# Normality of Residuals

qqnorm(resid(mod.t.low.w))
qqline(resid(mod.t.low.w))

qqnorm(resid(mod.ci.low))
qqline(resid(mod.ci.low))

# Homoscedasticity of Residuals
plot(resid(mod.t.low.w) ~ fitted(mod.t.low.w))
plot(resid(mod.ci.low) ~ fitted(mod.ci.low))

#Independence: added in bucket as a random intercept

# Fit the full model with the random effect
mod.full <- lme(thick.mgmm2 ~ (T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))

# Fit the null model without the random effect
mod.null <- gls(thick.mgmm2 ~ (T.),
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))
# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

# Fit the full model with the random effect
mod.full <- lme(CI ~ (T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit)

# Fit the null model without the random effect
mod.null <- gls(CI ~ (T.),
                data= (low.S),
                na.action=na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE



#FINAL MODEL
mod.finalthick = lme(thick.mgmm2 ~ (T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | T.))
mod.finalci = lme(CI ~ (T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit)

summary(mod.finalthick)
summary(mod.finalci)

library(MuMIn)
r.squaredGLMM(object = mod.finalthick, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

r.squaredGLMM(object = mod.finalci, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```
on shell area growth; difference between treatments
```{r}
#quick look at the effect of TA (vs omega?)
boxplot(low.S$Net_growth.d ~ as.factor(round(low.S$med.ta,-2)))

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages

# Perform Levene's test for variance homogeneity
levene_test_result <- leveneTest(Net_growth.d ~ factor(TA.treat.x), data = low.S)
# Summarize the Levene's test result
print(levene_test_result)

#does NOT pass test; TRIED TRANSFORMATION (SHIFT TO POS IE +1 AND THEN SQRT OR LOG RESPONSE). NEITHER FIXED ISSUE AND SO AM GIVING WEIGHTED VARIANCE BY TA TREATMENT
low.S$Net_growth.d.TRANS = as.numeric(log(low.S$Net_growth.d+1))

#Normality: looking for Gaussian distribution
hist((low.S$Net_growth.d.TRANS)) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start +
                factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit)

mod.wt <- lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))
anova(mod.full, mod.wt) #improves the model fit; will keep!

#KEEP THE RANDOM EFFECT. 

# Fit the full model with the random effect
mod.full <- lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))


# Fit the null model without the random effect
mod.null <- gls((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE


mod.full <- lmer(Net_growth.d.TRANS ~ SA.start + factor(TA.treat.x) + (1 | bucket), data = low.S, na.action = na.omit)

  mod.sa = lmer(Net_growth.d.TRANS ~ factor(TA.treat.x) + (1 | bucket), data = low.S, na.action = na.omit)
  

#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 35.729, p = 2.267e-09

low.S$TA.treat.x = as.factor(low.S$TA.treat.x)

#FINAL MODEL
#for the table parameter estimated
mod.final = lme((Net_growth.d) ~ SA.start + 
                factor(T.),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))
r.squaredGLMM(object = mod.final, null = mod.RE)
     #r2m WHAT WE ARE INTERESTED IN?
   #r2c

#estimates: 
summary(mod.final)
```
###comparing between salinity at TA near ambient
```{r}
g = end[end$sal.treat.x == "amb" & end$TA.treat.x == 2000,]
gg = end[end$sal.treat.x == "low" & end$TA.treat.x == 3000,]
#ambient salinity
amb.TA = rbind(g,gg)

```
on shell growth; HIGHER GROWTH IN LOW s (similar TA and high >2.5 OmC)
```{r}
#quick look at the effect of TA (vs omega?)
boxplot(amb.TA$Net_growth.d ~ as.factor(round(amb.TA$med.S,0)))


#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start +
                factor(sal.treat.x),
                random  = ~1 | bucket,
                data= (amb.TA),
                na.action=na.omit)

# Calculate weights based on squared residuals (variance of the error terms)
mod.full.w <- lme((Net_growth.d) ~ SA.start + 
                factor(sal.treat.x),
                random = ~1 | bucket,
                data = (amb.TA),
                weights = varIdent(form = ~ 1 | sal.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
anova(mod.full, mod.full.w)

#it is an improved fit! Good to go.

# Residuals vs. Fitted Values
plot(mod.full.w)

# Normality of Residuals
qqnorm(resid(mod.full.w))
qqline(resid(mod.full.w))

# Homoscedasticity of Residuals
plot(resid(mod.full.w) ~ fitted(mod.full.w))


#Independence: added in bucket as a random intercept

#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start + 
                factor(sal.treat.x),
                random = ~1 | bucket,
                data = (amb.TA),
                weights = varIdent(form = ~ 1 | sal.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)


summary(mod.full)

#Normality: looking for Gaussian distribution
hist(resid(mod.full)) #looks okay!
plot(resid(mod.full) ~ amb.TA$Net_growth.d)
plot(mod.full) #std resid vs fitted values looks okay!

#KEEP THE RANDOM EFFECT. 

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(Net_growth.d ~ SA.start + factor(sal.treat.x), random = ~1|bucket,
                 data = amb.TA,
                 na.action = na.omit)

# Fit the null model without the random effect
mod.null <- gls(Net_growth.d ~ SA.start + factor(sal.treat.x),
                 data = amb.TA,
                 na.action = na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

#effect of continuous predictors

mod.full <- lmer(Net_growth.d ~ SA.start + factor(sal.treat.x) + (1 | bucket), data = amb.TA, na.action = na.omit)

  mod.sa = lmer(Net_growth.d ~ factor(sal.treat.x) + (1 | bucket), data = amb.TA, na.action = na.omit)

#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 25.82, p = 3.749e-07

#FINAL MODEL
mod.final = lme((Net_growth.d) ~ SA.start + 
                factor(sal.treat.x),
                random = ~1 | bucket,
                data = (amb.TA),
                weights = varIdent(form = ~ 1 | sal.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
summary(mod.final)

r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c
```
on shell thickness; NO DIFFERENCE
```{r}
#quick look at the effect of TA
boxplot(amb.TA$thick.mgmm2 ~ as.factor(amb.TA$sal.treat.x), outline = F)

mod.full <- lme((thick.mgmm2) ~ factor(sal.treat.x),
                random  = ~1 | bucket,
                data= (amb.TA),
                na.action=na.omit)
summary(mod.full)


#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages

# Perform Levene's test for variance homogeneity
levene_test_result <- leveneTest(thick.mgmm2 ~ factor(sal.treat.x), data = amb.TA)
# Summarize the Levene's test result
print(levene_test_result)

#Normality: looking for Gaussian distribution
hist((amb.TA$thick.mgmm2)) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. NO DIFFERENCE
mod.full <- lme((thick.mgmm2) ~ factor(sal.treat.x),
                random  = ~1 | bucket,
                data= (amb.TA),
                na.action=na.omit)
summary(mod.full)

```
###low salinity
incremental split on area surface area growth? 
```{r}

boxplot(incr_growth.d ~ dps + round(med.ta,-2), data = inc[inc$med.S < 31,], outline = F)

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages
inc$dps.F = as.factor(inc$dps)
# Perform Levene's test for variance homogeneity
#levene_test_result <- leveneTest(incr_growth.d ~ dps.F, data = inc[inc$sal.treat.x == "amb",])
# Summarize the Levene's test result
#print(levene_test_result)
# Perform Levene's test for variance homogeneity
#levene_test_result <- leveneTest(incr_growth.d ~ factor(TA.treat.x), data = inc[inc$sal.treat.x == "amb",])
# Summarize the Levene's test result
#print(levene_test_result)

#inc$incr_growth.d.TRANS = as.numeric(sqrt(inc$incr_growth.d+5))

#model with all predictors. 
mod.full <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit)

# Calculate weights based on squared residuals (variance of the error terms)
mod.full.w <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))  # Use the inverse of squared residuals as weights)
  #it is an improved fit! Good to go.
anova(mod.full, mod.full.w)

# Residuals vs. Fitted Values
plot(mod.full)

# Normality of Residuals
qqnorm(resid(mod.full))
qqline(resid(mod.full))

# Homoscedasticity of Residuals
plot(resid(mod.full) ~ fitted(mod.full))


#Independence: added in bucket as a random intercept

#Normality: looking for Gaussian distribution
hist(resid(mod.full)) #looks okay!

#KEEP THE RANDOM EFFECT. 

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit)

# Fit the null model without the random effect
mod.null <- gls(incr_growth.d ~ TA.treat.x * dps.F,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE


#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 25.82, p = 3.749e-07

#FINAL MODEL
mod.final = lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit)
summary(mod.final)

r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c


```
        MODEL 3: What is the effect of [TA] on tissue growth at ambient and lower salinity?
###tissue wt NO EFFECT
```{r}
#looking at the effect of TA (vs omega?) on gut
boxplot(end$gut.wt ~ end$sal.treat.x*end$TA.treat.x, outline = F)

# Perform Levene's test for variance homogeneity
levene_test_result1 <- leveneTest(gut.wt ~ factor(TA.treat.x), data = end)
levene_test_result2 <- leveneTest(gut.wt ~ factor(sal.treat.x), data = end)
# Summarize the Levene's test result  PASSED TEST
print(c(levene_test_result1, levene_test_result2))

#Normality: looking for Gaussian distribution
hist(end$gut.wt) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. 
# Fit the full model
mod.full <- lme(gut.wt ~ factor(T.), random = ~1 | bucket, data = end, na.action = na.omit)


# Perform the ANOVA to test the significance of the factor
summary(mod.full)

#KEEP THE RANDOM EFFECT. 
# Fit the mixed-effects model
mod.full <- lme(gut.wt ~ factor(T.), random  = ~1 | bucket, data= end, na.action=na.omit)
#Test the significance of random effects (ie; test how much variance is accounted for by REs)
mod.RE <- gls(gut.wt ~ factor(T.), data= end, na.action=na.omit)
#mod.test<- gls(sqrt(Richness)~NAP*fExposure,method="REML",data=rikz)#remove the random effect; need to use gls bc lme/lme have to have a RE listed
#compare the two models; runs Log Likelihood Ratio test to test effect of random effect in model; P VALUE SAYS EFFECT OF BIN IS IMPORTANT.

#bucket does not contribute signifincant variance

#for table: 
anova(mod.full, mod.RE)    #effect of RE

#FINAL MODEL
mod.final = lme(gut.wt ~ factor(T.), random  = ~1 | bucket, data= end, na.action=na.omit)
```
###tissue versus condition index NO EFFECT
```{r}
#looking at the effect of TA (vs omega?) on gut and CI
boxplot(end$CI
        ~ end$sal.treat.x*end$TA.treat.x, outline = F)

# Perform Levene's test for variance homogeneity
levene_test_result1 <- leveneTest(CI ~ factor(TA.treat.x), data = end)
levene_test_result2 <- leveneTest(CI ~ factor(sal.treat.x), data = end)
# Summarize the Levene's test result  PASSED TEST
print(c(levene_test_result1, levene_test_result2))

#Normality: looking for Gaussian distribution
hist(end$gut.wt) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. 
# Fit the full model
mod.full <- lme(CI ~ factor(T.), random = ~1 | bucket, data = end, na.action = na.omit)


# Perform the ANOVA to test the significance of the factor
summary(mod.full)

#KEEP THE RANDOM EFFECT. 
# Fit the mixed-effects model
mod.full <- lme(CI ~ factor(T.), random  = ~1 | bucket, data= end, na.action=na.omit)
#Test the significance of random effects (ie; test how much variance is accounted for by REs)
mod.RE <- gls(CI ~ factor(T.), data= end, na.action=na.omit)
#mod.test<- gls(sqrt(Richness)~NAP*fExposure,method="REML",data=rikz)#remove the random effect; need to use gls bc lme/lme have to have a RE listed
#compare the two models; runs Log Likelihood Ratio test to test effect of random effect in model; P VALUE SAYS EFFECT OF BIN IS IMPORTANT.

#bucket does contribute signifincant variance

#for table: 
anova(mod.full, mod.RE)    #effect of RE

#FINAL MODEL
mod.final = lme(gut.wt ~ factor(T.), random  = ~1 | bucket, data= end, na.action=na.omit)
```
      Supplementary info and calculations:
###mortality/loss
```{r}
mort = dat %>%
  # first sort by year
  group_by(T.) %>% summarise(mort = (49*2) - mean(nrow),mort.frac = mort/(49*2), ave.tiss = mean(gut.wt), ave.net.d = mean(Net_growth.d))

dat$mort = NA
dat[dat$T. == "T1",]$mort <- mort[mort$T. == "T1",]$mort.frac
dat[dat$T. == "T2",]$mort <- mort[mort$T. == "T2",]$mort.frac
dat[dat$T. == "T3",]$mort <- mort[mort$T. == "T3",]$mort.frac
dat[dat$T. == "t1",]$mort <- mort[mort$T. == "t1",]$mort.frac
dat[dat$T. == "t2",]$mort <- mort[mort$T. == "t2",]$mort.frac
dat[dat$T. == "t3",]$mort <- mort[mort$T. == "t3",]$mort.frac

dat$surv = NA
dat$surv = 1 - dat$mort

# mort vectors
T1m = mean(dat[dat$T. == "T1",]$mort)
T2m = mean(dat[dat$T. == "T2",]$mort)
T3m = mean(dat[dat$T. == "T3",]$mort)
t1m = mean(dat[dat$T. == "t1",]$mort)
t2m = mean(dat[dat$T. == "t2",]$mort)
t3m = mean(dat[dat$T. == "t3",]$mort)
  
# combine two vectors using cbind 
# function
mort_data=cbind(T1m,T2m, T3m, t1m, t2m, t3m)


  dat$nrow.plate = NA
#to figure out how to get plate level mortality for the error bars
  # Iterate over each plate#
for (plate in 1:12) {
  # Subset data for the current Bin#
  subset_data <- end[end$Plate.x == plate, ]
  
  # Calculate the median TA for the current Bin#
  nrow.plate <- nrow(subset_data)
  
  # Assign the median value to the corresponding row in the final result dataframe
  dat[dat$Plate.x == plate, "nrow.plate"] <- nrow.plate
}
  SE.T1 = mean(unique(dat[dat$T. == "T1",]$mort))/sqrt(2)
  SE.T2 = mean(unique(dat[dat$T. == "T2",]$mort))/sqrt(2)
  SE.T3 = mean(unique(dat[dat$T. == "T3",]$mort))/sqrt(2)
  SE.t1 = mean(unique(dat[dat$T. == "t1",]$mort))/sqrt(2)
  SE.t2 = mean(unique(dat[dat$T. == "t2",]$mort))/sqrt(2)
  SE.t3 = mean(unique(dat[dat$T. == "t3",]$mort))/sqrt(2)
  
# pass this college_data to the 
# barplot
barplot(1-mort_data,beside=T, xaxt='n', ann=FALSE, yaxt='n', xlim = c(0,13), ylim = c(0,1))
lines(x = c(0,15),y=c(0,0), lwd = 1.5)
lines(x = c(0,0),y=c(0,1), lwd = 1.5)
axis(side = 2, labels = c("0","0.2","0.4","0.6","0.8","1.0"), at = c(0,0.2,0.4,0.6,0.8,1), las = 1, tick = F, line = -1.25)
axis(side = 2, labels = "Proportion survival", at = 0.5, cex = 1.5, line = 0.75, tick = F)
axis(side = 1, labels = c("ambient (S = 34)","low (S = 27)"), at = c(3.5,9.5), cex = 1.5, line = -0.5, tick = F)
  axis(side = 1, labels = c("X","X","X"), at = c(1.5,3.5,5.5), cex = 1.5, line = 0.75, tick = F)
    axis(side = 1, labels = c("X","X","X"), at = c(7.5,9.5,11.5), cex = 1.5, line = 0.75, tick = F)
  axis(side = 1, labels = c("total alkalinity concentration"), at = c(6.5), cex = 1.5, line = 2, tick = F)
  abline(h=0.9, lty = 2, lwd = 2)
  lines(x = c(1.5,1.5), y = c((1-T1m)+SE.T1, (1-T1m)-SE.T1), lwd = 2)
    lines(x = c(3.5,3.5), y = c((1-T2m)+SE.T2, (1-T2m)-SE.T2), lwd = 2)
    lines(x = c(5.5,5.5), y = c((1-T3m)+SE.T3, (1-T3m)-SE.T3), lwd = 2)
    lines(x = c(7.5,7.5), y = c((1-t1m)+SE.t1, (1-t1m)-SE.t1), lwd = 2)
    lines(x = c(9.5,9.5), y = c((1-t2m)+SE.t2, (1-t2m)-SE.t2), lwd = 2)
    lines(x = c(11.5,11.5), y = c((1-t3m)+SE.t3, (1-t3m)-SE.t3), lwd = 2)
  

```
###patterns of controls for ablines in figures...NOT DONE
```{r}
# SHELL WEIGHT 
plot(control$shell.wt~control$SA.mm2)
abline(lm(control$shell.wt~control$SA.mm2)) #relat between SA and wt

#after treatments
plot(end$shell.wt ~ end$SA.mm2, pch = 19, col = as.factor(end$bucket))
#add back the trend from control/
abline(lm(control$shell.wt~control$SA.mm2)) #relat between SA and wt

#writing a model that compares the slope of each treatment (n=2 bins) to the control.
mod.slope = lm(shell.wt ~ SA.mm2 + med.S + med.ta, data = end)
summary(mod.slope) #Shell wt both went up about 0.2 g per unit increase in SA mm2...it was a little higher but still similar to control. 

# TISSUE WEIGHT
boxplot(control$gut.wt~control$Plate)
summary(lm(control$gut.wt~factor(control$Plate))) #relat between gut and pre or post
# gut weight 2.24 post ave and 5.1 pre ave

#after treatments
boxplot(end$gut.wt ~ round(end$med.S,0), pch = 19)
#add back the trend from control/
boxplot(end$gut.wt ~ round(end$med.ta,-2), pch = 19)
abline(h = c(2.24,5.1),lty = 2) #relat between SA and wt

# CONDITION INDEX
boxplot((gut.wt/shell.wt)~Plate, data = control)
summary(lm((control$gut.wt/control$shell.wt)~factor(control$Plate))) #relat between gut and pre or post
# gut weight 0.0089 post ave and 0.0076 pre ave

#after treatments
boxplot((end$gut.wt/end$shell.wt) ~ round(end$med.S,0), pch = 19)
#add back the trend from control/
boxplot(end$CI ~ round(end$med.ta,-2), pch = 19)
abline(h = c(0.0089,0.0076),lty = 2) #relat between SA and wt

#quick model to see if 2000 is higher?
summary(lm(end$CI ~ factor(round(end$med.ta,-2))))

```
###average shell area, tissue mass, CI
```{r}
m.gut = mean(end$gut.wt)
se.gut = mean(end$gut.wt)/sqrt(nrow(end))

m.gut2 = mean(control$gut.wt)
se.gut2 = mean(control$gut.wt/sqrt(nrow(control)))

m.ci = mean(end$CI)
se.ci = mean(end$CI)/sqrt(nrow(end))

m.ci2 = mean(control$gut.wt/control$shell.wt)
se.ci2 = mean((control$gut.wt/control$shell.wt)/sqrt(nrow(control)))

m.area = mean(end$SA.mm2.RE)
se.area = mean(end$SA.mm2.RE)/sqrt(nrow(end))

m.area2 = mean(control$SA.mm2)
se.area2 = mean(control$SA.mm2/sqrt(nrow(control)))

```


###Figure 3: Incremental shell growth AMBIENT SALINITY
```{r}

#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
boxplot(incr_growth.d ~ TA.treat.x, ylab = NA, xlab = NA, names= NA, ylim = c(-1,3.6), frame.plot = F, xlim = c(0.25,5), axes = F, data = (inc[inc$dps == 18 & inc$sal.treat.x == "amb",]), outline = F)
#text(x = 7.5, y = 2.9, labels = c("Time increment"), cex = 1.25)
#legend(x=6,y=2.85,fill = c("grey","grey40"),legend = c("0 - 18 dps","18 - 36 dps"),bty = "n", cex = 1.2, x.intersp=0.4)
lines(x= c(0.25,5), y=c(-1,-1), lwd = 2)
lines(x= c(0.25,0.25), y=c(-1,3.5), lwd = 2)

axis(side = 1, line = -0.9, tick = F, at = c(1,2,3), labels = c("'low'","'ambient'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.1)

axis(side = 2, line = -1.5, tick = F, at = c(-.5,.5,1.5,2.5,3.5), labels = c("-0.5","0.5","1.5","2.5", "3.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 2.1, tick = F, at = 1.25, labels = 'Incremental growth rate', cex.axis = 1.1)
axis(side = 2, line = 0.75, tick = F, at = 1.25, labels = expression(paste(' (mm'^2,' d'^-1,')')), cex.axis = 1.1)


boxplot(incr_growth.d ~ TA.treat.x, ylab = NA, xlab = NA, names= NA, ylim = c(-1,1.5), frame.plot = F, xlim = c(0.25,5), axes = F, data = (inc[inc$dps == 36 & inc$sal.treat.x == "amb",]), outline = F, col = "grey40")
#text(x = 7.5, y = 2.9, labels = c("Time increment"), cex = 1.25)
#legend(x=6,y=2.85,fill = c("grey","grey40"),legend = c("0 - 18 dps","18 - 36 dps"),bty = "n", cex = 1.2, x.intersp=0.4)
lines(x= c(0.25,5), y=c(-1,-1), lwd = 2)
lines(x= c(0.25,0.25), y=c(-1,1.5), lwd = 2)

axis(side = 1, line = -0.9, tick = F, at = c(1,2,3), labels = c("'low'","'ambient'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.1)

axis(side = 2, line = -1.5, tick = F, at = c(-1,-.5,0,0.5,1,1.5), labels = c("-1.0","-0.5","0","0.5","1.0","1.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 2.1, tick = F, at = 0.25, labels = 'Incremental growth rate', cex.axis = 1.1)
axis(side = 2, line = 0.75, tick = F, at = 0.25, labels = expression(paste(' (mm'^2,' d'^-1,')')), cex.axis = 1.1)


```

###Figure 4: Incremental shell growth LOW SALINITY
```{r}

#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
boxplot(incr_growth.d ~ TA.treat.x, ylab = NA, xlab = NA, names= NA, ylim = c(-1,3.6), frame.plot = F, xlim = c(0.25,5), axes = F, data = (inc[inc$dps == 18 & inc$sal.treat.x == "low",]), outline = F)
#text(x = 7.5, y = 2.9, labels = c("Time increment"), cex = 1.25)
#legend(x=6,y=2.85,fill = c("grey","grey40"),legend = c("0 - 18 dps","18 - 36 dps"),bty = "n", cex = 1.2, x.intersp=0.4)
lines(x= c(0.25,5), y=c(-1,-1), lwd = 2)
lines(x= c(0.25,0.25), y=c(-1,3.5), lwd = 2)

axis(side = 1, line = -0.9, tick = F, at = c(1,2,3), labels = c("'DI'","'Low'","'High'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.1)

axis(side = 2, line = -1.5, tick = F, at = c(-.5,.5,1.5,2.5,3.5), labels = c("-0.5","0.5","1.5","2.5", "3.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 2.1, tick = F, at = 1.25, labels = 'Incremental growth rate', cex.axis = 1.1)
axis(side = 2, line = 0.75, tick = F, at = 1.25, labels = expression(paste(' (mm'^2,' d'^-1,')')), cex.axis = 1.1)


boxplot(incr_growth.d ~ TA.treat.x, ylab = NA, xlab = NA, names= NA, ylim = c(-1,1.5), frame.plot = F, xlim = c(0.25,5), axes = F, data = (inc[inc$dps == 36 & inc$sal.treat.x == "low",]), outline = F, col = "grey40")
#text(x = 7.5, y = 2.9, labels = c("Time increment"), cex = 1.25)
#legend(x=6,y=2.85,fill = c("grey","grey40"),legend = c("0 - 18 dps","18 - 36 dps"),bty = "n", cex = 1.2, x.intersp=0.4)
lines(x= c(0.25,5), y=c(-1,-1), lwd = 2)
lines(x= c(0.25,0.25), y=c(-1,1.5), lwd = 2)

axis(side = 1, line = -0.9, tick = F, at = c(1,2,3), labels = c("'DI'","'Low'","'High'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.1)

axis(side = 2, line = -1.5, tick = F, at = c(-1,-.5,0,0.5,1,1.5), labels = c("-1.0","-0.5","0","0.5","1.0","1.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 2.1, tick = F, at = 0.25, labels = 'Incremental growth rate', cex.axis = 1.1)
axis(side = 2, line = 0.75, tick = F, at = 0.25, labels = expression(paste(' (mm'^2,' d'^-1,')')), cex.axis = 1.1)


```

###Figure 5: NET EFFECTS ON SHELL MASS PER AREA and CONDITION INDEX: AMBIENT SALINITY
```{r}
boxplot(((amb.S$thick.mgmm2)) ~ amb.S$TA.treat.x, pch = 19, ylab = NA, xlab = NA, names= NA, ylim = c(0.5,5), frame.plot = F, xlim = c(0.25,4), axes = F, outline = F)
lines(x= c(0.25,4), y=c(0.5,0.5), lwd = 2)
lines(x= c(0.25,0.25), y=c(0.5,5), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'low'","~'ambient'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(1,2,3,4,5), labels = c("1.0","2.0","3.0", "4.0", "5.0"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 3, labels = 'Shell mass per surface area', cex.axis = 1.15)
axis(side = 2, line = 0.2, tick = F, at = 3, labels = expression(paste('(mg mm'^-2,')')), cex.axis = 1.15)

boxplot(((amb.S$CI)) ~ amb.S$TA.treat.x, pch = 19, ylab = NA, xlab = NA, names= NA, ylim = c(0,0.03), frame.plot = F, xlim = c(0.25,4), axes = F, outline = F)
lines(x= c(0.25,4), y=c(0,0), lwd = 2)
lines(x= c(0.25,0.25), y=c(0,0.035), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'low'","~'ambient'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(0,0.01,0.02,0.03), labels = c("0","0.01","0.02", "0.03"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 2, tick = F, at = 0.015, labels = 'Condition index ', cex.axis = 1.15)
axis(side = 2, line = 0.6, tick = F, at = 0.015, labels = expression(paste('(mg mg'^-1,')')), cex.axis = 1.15)

```

###Figure 6: NET EFFECTS ON SHELL MASS PER AREA and CONDITION INDEX: LOW SALINITY
```{r}
boxplot(((low.S$thick.mgmm2)) ~ low.S$TA.treat.x, pch = 19, ylab = NA, xlab = NA, names= NA, ylim = c(0.5,5), frame.plot = F, xlim = c(0.25,4), axes = F, outline = F)
lines(x= c(0.25,4), y=c(0.5,0.5), lwd = 2)
lines(x= c(0.25,0.25), y=c(0.5,5), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'DI'","'low'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(1,2,3,4,5), labels = c("1.0","2.0","3.0", "4.0", "5.0"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 3, labels = 'Shell mass per surface area', cex.axis = 1.15)
axis(side = 2, line = 0.2, tick = F, at = 3, labels = expression(paste('(mg mm'^2,')')), cex.axis = 1.15)

boxplot(((low.S$CI)) ~ low.S$TA.treat.x, pch = 19, ylab = NA, xlab = NA, names= NA, ylim = c(0,0.03), frame.plot = F, xlim = c(0.25,4), axes = F, outline = F)
lines(x= c(0.25,4), y=c(0,0), lwd = 2)
lines(x= c(0.25,0.25), y=c(0,0.035), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'DI'","'low'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(0,0.01,0.02,0.03), labels = c("0","0.01","0.02", "0.03"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 2, tick = F, at = 0.015, labels = 'Condition index ', cex.axis = 1.15)
axis(side = 2, line = 0.6, tick = F, at = 0.015, labels = expression(paste('(mg mg'^2,')')), cex.axis = 1.15)

```

Seawater table with carbonate system parameters listed for each treatment (ave +- SE)
```{r}

```

###extra
#################################
Figure 4: Effect of TA in lower S on surface area growth rate?
```{r}
boxplot(Net_growth.d ~ TA.treat.x, pch = 19, ylab = NA, xlab = NA, names= NA, ylim = c(-0.6,1.7), frame.plot = F, xlim = c(0.25,4), axes = F, data = low.S, outline = F)
lines(x= c(0.25,4), y=c(-0.6,-0.6), lwd = 2)
lines(x= c(0.25,0.25), y=c(-0.6,3), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'DI'","'low TA'","'high TA'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Fresh water source", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(-0.5,0,0.5,1.0,1.5), labels = c("-0.5","0","0.5", "1.0", "1.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 0.5, labels = 'Net surface area growth rate', cex.axis = 1.15)
axis(side = 2, line = 0.2, tick = F, at = 0.5, labels = expression(paste('(mm'^2,' d'^-1,')')), cex.axis = 1.15)

text(x = 1, y = 1.25, label = "a", cex = 1.15)
text(x = 2, y = 0.75, label = "a", cex = 1.15)
text(x = 3, y = 1.7, label = "b", cex = 1.15)
```
extra/supplementary?
CI
```{r}
#effect of TA and amb on condition index
boxplot(CI ~ TA.treat.x, data = amb.S, outline = F,ylim = c(0.005,0.03), ylab = NA, xlab = NA, names= NA, frame.plot = F, xlim = c(0.25,3.5), axes = F)
lines(x= c(0.25,4), y=c(0.005,0.005), lwd = 2)
lines(x= c(0.25,0.25), y=c(0.005,0.03), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'low'","~'ambient'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(0.006,0.0105,0.015,0.02,0.025,0.03), labels = c("0.005","0.01","0.015","0.02","0.025","0.03"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.5, tick = F, at = 0.0175, labels = 'Condition index (tissue/shell mass)', cex.axis = 1.25)
        
#effect of TA on condition index low salinity
boxplot(CI ~ TA.treat.x, data = low.S, outline = F,ylim = c(0.005,0.03), ylab = NA, xlab = NA, names= NA, frame.plot = F, xlim = c(0.25,3.5), axes = F)
lines(x= c(0.25,4), y=c(0.005,0.005), lwd = 2)
lines(x= c(0.25,0.25), y=c(0.005,0.03), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'DI'","'Low TA'","'High TA'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(0.006,0.0105,0.015,0.02,0.025,0.03), labels = c("0.005","0.01","0.015","0.02","0.025","0.03"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.5, tick = F, at = 0.0175, labels = 'Condition index (tissue/shell mass)', cex.axis = 1.25)

```

not significant; incremental growth per start area (dps = 0, dps = 18); survival
```{r}
inc$incr_growth.d.mm2 = NA
inc$SA.mod = NA
inc[inc$dps == 18,]$incr_growth.d.mm2 = inc[inc$dps == 18,]$incr_growth.d/inc[inc$dps == 18,]$SA.start

inc[inc$dps == 18,]$SA.mod <- (inc[inc$dps == 18,]$SA.start)

inc[inc$dps == 36,]$SA.mod <- (inc[inc$dps == 36,]$SA.dps18)

inc[inc$dps == 36,]$incr_growth.d.mm2 = inc[inc$dps == 36,]$incr_growth.d/inc[inc$dps == 36,]$SA.dps18


summary(lme(incr_growth.d.mm2 ~ as.numeric(SA.mod) * as.factor(dps), random = ~1|bucket, data = inc))


#Figure 
boxplot(inc$incr_growth.d.mm2 ~ inc$dps)


#extra figure to alter
plot(inc$incr_growth.d.mm2 ~ inc$SA.mod, bty = "n", type = "n", axes = F, xlim = c(50,300), ylim = c(-0.012,0.03), xlab = NA, ylab = NA)

points((inc[inc$dps == 36,]$incr_growth.d.mm2 ~ inc[inc$dps == 36,]$SA.mod), pch = 21, bg = "grey40")
points((inc[inc$dps == 18,]$incr_growth.d.mm2 ~ inc[inc$dps == 18,]$SA.mod), pch = 21, bg = "grey")
lines(x= c(50,300), y=c(-0.012,-0.012), lwd = 2)
lines(x= c(50,50), y=c(-0.012,0.03), lwd = 2)

axis(side = 1, line = -0.9, tick = F, at = c(53,100,150,200,250,300), labels = c("50","100","150","200","250","300"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 175, labels = "Size at start of increment (mm2)", cex.axis = 1.1)

axis(side = 2, line = -1.75, tick = F, at = c(-0.005,0.005,0.015,0.025), labels = c("-0.005","0.005","0.015","0.025"), cex.axis = 1.1, las = 2)
axis(side = 2, line = 2.25, tick = F, at = 0.01, labels = "incremental per area", cex.axis = 1.1)
axis(side = 2, line = 1.25, tick = F, at = 0.01, labels = "growth rate (d-1)", cex.axis = 1.1)

lines(x=c(55,300), y=c(0.0063,0.0063), lwd = 3, col = "grey", lty = 2) #intercept > 0 but slope == 0
lines(x=c(55,300), y=c(0.002788592,-0.0045456), lwd = 3, col = "grey40", lty = 2)
```
