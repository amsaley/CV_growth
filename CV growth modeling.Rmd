---
title: "CV growth"
output: html_document
date: "2023-09-20"
editor_options: 
  chunk_output_type: console
---

loading in library and datafiles
```{r}
setwd("C:/Users/alish/OneDrive/Documents/GitHub/CV_growth/data files")
library(readxl)
library(lme4)
library(lmerTest)
dat = read.csv("C:/Users/alish/OneDrive/Documents/GitHub/CV_growth/data files/dat.processed.csv")
dat = dat[dat$CI > 0.005,]
control = read_xlsx("control cv.xlsx")
```
grouping treatments by treatments; creating end and inc
```{r}
dat$T. = 0
dat[dat$sal.treat.x == "amb" & dat$TA.treat.x == "1000",]$T. <- "T1"
dat[dat$sal.treat.x == "amb" & dat$TA.treat.x == "2000",]$T. = "T2"
dat[dat$sal.treat.x == "amb" & dat$TA.treat.x == "3000",]$T. = "T3"

dat[dat$sal.treat.x == "low" & dat$TA.treat.x == "1000",]$T. = "t1"
dat[dat$sal.treat.x == "low" & dat$TA.treat.x == "2000",]$T. = "t2"
dat[dat$sal.treat.x == "low" & dat$TA.treat.x == "3000",]$T. = "t3"

nT1 = nrow(dat[dat$T. == "T1" & dat$dps == 36,])
nT2 = nrow(dat[dat$T. == "T2" & dat$dps == 36,])
nT3 = nrow(dat[dat$T. == "T3" & dat$dps == 36,])
nt1 = nrow(dat[dat$T. == "t1" & dat$dps == 36,])
nt2 = nrow(dat[dat$T. == "t2" & dat$dps == 36,])
nt3 = nrow(dat[dat$T. == "t3" & dat$dps == 36,])

dat$nrow = 0
dat[dat$T. == "T1",]$nrow <- nT1
dat[dat$T. == "T2",]$nrow <- nT2
dat[dat$T. == "T3",]$nrow <- nT3
dat[dat$T. == "t1",]$nrow <- nt1
dat[dat$T. == "t2",]$nrow <- nt2
dat[dat$T. == "t3",]$nrow <- nt3

#Removing outlier points from the data set
plot(dat$Net_growth.d)
summary(dat$Net_growth.d)
q1 = 0.1903
q3 = 0.8038
iqr = q3-q1
max = q3+(1.5*iqr)
  min = q1-(1.5*iqr)
plot(dat$Net_growth.d)
abline(h=c(min,max))


#after 5 weeks of exposure
end = subset(dat,
             dps == 36 &
             Net_growth.d < max)
end$Net_growth.w.trans = log(end$Net_growth.w + 10)

plot((Net_growth.w.trans) ~ med.ta, pch = 19, col = as.factor(sal.treat.x), data = end)

#for incremental growth we need to delete the first time step
inc = subset(dat,
             dps >1&
             Net_growth.d < max)

#adding in a column for thickness of shell
end$thick.mgmm2 = end$shell.wt/end$SA.mm2.RE

```

MODELS ------------------------

summary stats for different treatments
```{r}
#ambient salinity
amb.S = as.data.frame(end[end$sal.treat.x == "amb",])
#low salinity
low.S = as.data.frame(end[end$sal.treat.x == "low",])
```
Checking assumptions of ANOVA model:
1. Normality – Each sample was drawn from a normally distributed population, ie The errors or residuals are normally distributed. This can be checked by using a normality test or a QQ-plot.

2. Equal Variances – The variances of the populations that the samples come from are equal. The errors or residuals have constant variance, mean zero, and are independent. This can be checked by plotting the residuals against the predictors and looking for any patterns or outliers.

3. Independence – The observations in each group are independent of each other and the observations within groups were obtained by a random sample. This can be resolved with random effects.

Checking the assumptions of an LME
The model you've specified using lme in R is a linear mixed-effects model. There are several assumptions associated with this type of model that you should verify to ensure the validity of your results and conclusions. Let's discuss the key assumptions and how you can check them in R:

Linearity:
Assumption: The relationship between the predictor variables (SA.start and TA.treat.x) and the response variable (Net_growth.d.TRANS) is linear.
Verification: Plot residuals against the fitted values and predictor variables to check for linearity.

Normality of Residuals:
Assumption: The residuals are normally distributed.
Verification: Plot a histogram or a Q-Q plot of the residuals to assess their normality.

Homoscedasticity of Residuals:
Assumption: The residuals have constant variance (homoscedasticity).
Verification: Plot residuals against the fitted values or predictor variables to check for patterns or changes in variance.

Independence of Residuals:
Assumption: The residuals are independent of each other.
Verification: Plot residuals against time or any other relevant variable to check for autocorrelation or patterns.

Random Effects Assumption:
Assumption: The random effects (random intercepts for the 'bucket' variable) are normally distributed and independent of other variables.
Verification: Check the distribution of the random effects using summary statistics or plots.

Model Fit:
Assumption: The model fits the data well.
Verification: Examine model fit statistics such as AIC (Akaike Information Criterion) or BIC (Bayesian Information Criterion) to evaluate the model's fit.
         MODEL 1: What is the effect of [TA] on shell growth (thickness and surface area) at ambient and lower salinity?
         
###ambient salinity

on shell area growth; NO DIFFERENCE by TA, difference based on starting area size
```{r}
#quick look at the effect of TA (vs omega?)
boxplot(amb.S$Net_growth.d ~ as.factor(round(amb.S$med.ta,-3)))
boxplot(amb.S$Net_growth.d ~ as.factor(round(amb.S$med.OmC,0)))

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages
#testing variance heterskedasticity was done using a Bruesch-Pagan test https://www.statology.org/breusch-pagan-test-r/
library(nlme)

#transforming the data did not work and so instead I opted to apply weighted variance within the model that is equal to the inverse of the variance in each group (smaller variance gives larger weight within the SEs of the model )
#amb.S$Net_growth.d.TRANS = as.numeric(sqrt(amb.S$Net_growth.d+1))


#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start +
                factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit)

# Calculate weights based on squared residuals (variance of the error terms)
mod.full.w <- lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random = ~1 | bucket,
                data = (amb.S),
                weights = varIdent(form = ~ 1 | TA.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
anova(mod.full, mod.full.w)

#it is an improved fit! Good to go.

# Residuals vs. Fitted Values
plot(mod.full.w)

# Normality of Residuals
qqnorm(resid(mod.full.w))
qqline(resid(mod.full.w))

# Homoscedasticity of Residuals
plot(resid(mod.full.w) ~ fitted(mod.full.w))


#Independence: added in bucket as a random intercept

#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random = ~1 | bucket,
                data = (amb.S),
                weights = varIdent(form = ~ 1 | TA.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)


summary(mod.full)

#Normality: looking for Gaussian distribution
hist(resid(mod.full)) #looks okay!
plot(resid(mod.full) ~ amb.S$Net_growth.d)
plot(mod.full) #std resid vs fitted values looks okay!

#KEEP THE RANDOM EFFECT. 

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(Net_growth.d ~ SA.start + factor(TA.treat.x), random = ~1|bucket,
                 data = amb.S,
                 na.action = na.omit)

# Fit the null model without the random effect
mod.null <- gls(Net_growth.d ~ SA.start + factor(TA.treat.x),
                 data = amb.S,
                 na.action = na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

#effect of continuous predictors

mod.full <- lmer(Net_growth.d ~ SA.start + factor(TA.treat.x) + (1 | bucket), data = amb.S, na.action = na.omit)

  mod.sa = lmer(Net_growth.d ~ factor(TA.treat.x) + (1 | bucket), data = amb.S, na.action = na.omit)

#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 25.82, p = 3.749e-07

#FINAL MODEL
mod.final = lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random = ~1 | bucket,
                data = (amb.S),
                weights = varIdent(form = ~ 1 | TA.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
summary(mod.final)

r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```

on shell mass per area; NO DIFFERENCE
```{r}
#quick look at the effect of TA
boxplot(amb.S$thick.mgmm2 ~ as.factor(round(amb.S$med.ta,-3)), outline = T)

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages

# Perform Levene's test for variance homogeneity
levene_test_result <- leveneTest(thick.mgmm2 ~ factor(TA.treat.x), data = amb.S)
# Summarize the Levene's test result
print(levene_test_result)

#does NOT pass test; TRIED TRANSFORMATION SQRT OR LOG RESPONSE. NEITHER FIXED ISSUE AND SO i will used weighted variance term in the model to account for heteroscedasticity
#levene_test_result <- leveneTest(thick.mgmm2.TRANS ~ factor(TA.treat.x), data = amb.S)
#levene_test_result #still DOES NOT PASS; need a fix

#Normality: looking for Gaussian distribution
hist(log(amb.S$thick.mgmm2)) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. NO DIFFERENCE
mod.full <- lme((thick.mgmm2) ~ factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit)
#model with all predictors w weights
mod.wt <- lme((thick.mgmm2) ~ factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))

anova(mod.full, mod.wt) #significant p-value; we can keep the weighting as it significantly improves the model fit?

#for table: 
mod.final <- lme((thick.mgmm2) ~ factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (amb.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))

r.squaredGLMM(object = mod.final, null = mod.RE)
     #r2m WHAT WE ARE INTERESTED IN?
  #r2c

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(thick.mgmm2 ~ SA.start + factor(TA.treat.x), random = ~1|bucket,
                 data = amb.S,
                 na.action = na.omit)

# Fit the null model without the random effect
mod.null <- gls(thick.mgmm2 ~ SA.start + factor(TA.treat.x),
                 data = amb.S,
                 na.action = na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE


```

###low salinity

on shell area growth; difference between treatments
```{r}
#quick look at the effect of TA (vs omega?)
boxplot(low.S$Net_growth.d ~ as.factor(round(low.S$med.ta,-2)))

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages

# Perform Levene's test for variance homogeneity
levene_test_result <- leveneTest(Net_growth.d ~ factor(TA.treat.x), data = low.S)
# Summarize the Levene's test result
print(levene_test_result)

#does NOT pass test; TRIED TRANSFORMATION (SHIFT TO POS IE +1 AND THEN SQRT OR LOG RESPONSE). NEITHER FIXED ISSUE AND SO AM GIVING WEIGHTED VARIANCE BY TA TREATMENT
low.S$Net_growth.d.TRANS = as.numeric(log(low.S$Net_growth.d+1))

#Normality: looking for Gaussian distribution
hist((low.S$Net_growth.d.TRANS)) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start +
                factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit)

mod.wt <- lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))
anova(mod.full, mod.wt) #improves the model fit; will keep!

#KEEP THE RANDOM EFFECT. 

# Fit the full model with the random effect
mod.full <- lme(Net_growth.d ~ SA.start + factor(TA.treat.x), random = ~1|bucket,
                 data = low.S,
                 na.action = na.omit)

# Fit the null model without the random effect
mod.null <- gls(Net_growth.d ~ SA.start + factor(TA.treat.x),
                 data = low.S,
                 na.action = na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

#for table: 
anova(mod.full, mod.RE)    #effect of RE

mod.full <- lmer(Net_growth.d.TRANS ~ SA.start + factor(TA.treat.x) + (1 | bucket), data = low.S, na.action = na.omit)

  mod.sa = lmer(Net_growth.d.TRANS ~ factor(TA.treat.x) + (1 | bucket), data = low.S, na.action = na.omit)
  

#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 35.729, p = 2.267e-09

low.S$TA.treat.x = as.factor(low.S$TA.treat.x)

#FINAL MODEL
#for the table parameter estimated
mod.final = lme((Net_growth.d) ~ SA.start + 
                factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))
r.squaredGLMM(object = mod.final, null = mod.RE)
     #r2m WHAT WE ARE INTERESTED IN?
   #r2c

#estimates: 
summary(mod.final)
```

on shell mass per area; NO DIFFERENCE
```{r}
#quick look at the effect of TA
boxplot(low.S$thick.mgmm2 ~ as.factor(round(low.S$med.ta,-2)), outline = T)

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages

# Perform Levene's test for variance homogeneity
levene_test_result <- leveneTest(thick.mgmm2 ~ factor(TA.treat.x), data = low.S)
# Summarize the Levene's test result
print(levene_test_result)

#does NOT pass test; TRIED TRANSFORMATION SQRT OR LOG RESPONSE. NEITHER FIXED ISSUE AND SO AM KEEPING 

low.S$thick.mgmm2.TRANS = sqrt(low.S$thick.mgmm2)
boxplot(low.S$thick.mgmm2.TRANS ~ as.factor(round(low.S$med.ta,-2)), outline = F)
# Re-run the test with the transformed response
levene_test_result <- leveneTest(thick.mgmm2.TRANS ~ factor(TA.treat.x), data = low.S)
levene_test_result #still DOES NOT PASS; need a fix

#Normality: looking for Gaussian distribution
hist(log(low.S$thick.mgmm2)) #looks okay!

#Independence: added in bucket as a random intercept
#model with all predictors. NO DIFFERENCE
mod.full <- lme((thick.mgmm2) ~ factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit)
#model with all predictors w weights
mod.wt <- lme((thick.mgmm2) ~ factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))

anova(mod.full, mod.wt) #significant p-value; we can keep the weighting as it significantly improves the model fit?

#for table: 
mod.final <- lme((thick.mgmm2) ~ factor(TA.treat.x),
                random  = ~1 | bucket,
                data= (low.S),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x), method = "REML")

r.squaredGLMM(object = mod.final, null = mod.RE)
     #r2m WHAT WE ARE INTERESTED IN?
   #r2c
summary(mod.final)

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(thick.mgmm2 ~ SA.start + factor(TA.treat.x), random = ~1|bucket,
                 data = low.S,
                 na.action = na.omit)

# Fit the null model without the random effect
mod.null <- gls(thick.mgmm2 ~ SA.start + factor(TA.treat.x),
                 data = low.S,
                 na.action = na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE


```

###comparing between salinity at TA near ambient

```{r}
g = end[end$sal.treat.x == "amb" & end$TA.treat.x == 2000,]
gg = end[end$sal.treat.x == "low" & end$TA.treat.x == 3000,]
#ambient salinity
amb.TA = rbind(g,gg)

```

on shell growth; HIGHER GROWTH IN LOW s (similar TA and high >2.5 OmC)
```{r}
#quick look at the effect of TA (vs omega?)
boxplot(amb.TA$Net_growth.d ~ as.factor(round(amb.TA$med.S,0)))


#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start +
                factor(sal.treat.x),
                random  = ~1 | bucket,
                data= (amb.TA),
                na.action=na.omit)

# Calculate weights based on squared residuals (variance of the error terms)
mod.full.w <- lme((Net_growth.d) ~ SA.start + 
                factor(sal.treat.x),
                random = ~1 | bucket,
                data = (amb.TA),
                weights = varIdent(form = ~ 1 | sal.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
anova(mod.full, mod.full.w)

#it is an improved fit! Good to go.

# Residuals vs. Fitted Values
plot(mod.full.w)

# Normality of Residuals
qqnorm(resid(mod.full.w))
qqline(resid(mod.full.w))

# Homoscedasticity of Residuals
plot(resid(mod.full.w) ~ fitted(mod.full.w))


#Independence: added in bucket as a random intercept

#model with all predictors. 
mod.full <- lme((Net_growth.d) ~ SA.start + 
                factor(sal.treat.x),
                random = ~1 | bucket,
                data = (amb.TA),
                weights = varIdent(form = ~ 1 | sal.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)


summary(mod.full)

#Normality: looking for Gaussian distribution
hist(resid(mod.full)) #looks okay!
plot(resid(mod.full) ~ amb.TA$Net_growth.d)
plot(mod.full) #std resid vs fitted values looks okay!

#KEEP THE RANDOM EFFECT. 

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(Net_growth.d ~ SA.start + factor(sal.treat.x), random = ~1|bucket,
                 data = amb.TA,
                 na.action = na.omit)

# Fit the null model without the random effect
mod.null <- gls(Net_growth.d ~ SA.start + factor(sal.treat.x),
                 data = amb.TA,
                 na.action = na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE

#effect of continuous predictors

mod.full <- lmer(Net_growth.d ~ SA.start + factor(sal.treat.x) + (1 | bucket), data = amb.TA, na.action = na.omit)

  mod.sa = lmer(Net_growth.d ~ factor(sal.treat.x) + (1 | bucket), data = amb.TA, na.action = na.omit)

#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 25.82, p = 3.749e-07

#FINAL MODEL
mod.final = lme((Net_growth.d) ~ SA.start + 
                factor(sal.treat.x),
                random = ~1 | bucket,
                data = (amb.TA),
                weights = varIdent(form = ~ 1 | sal.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
summary(mod.final)

r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c
```

on shell thickness; NO DIFFERENCE
```{r}
#quick look at the effect of TA
boxplot(amb.TA$thick.mgmm2 ~ as.factor(amb.TA$sal.treat.x), outline = F)

mod.full <- lme((thick.mgmm2) ~ factor(sal.treat.x),
                random  = ~1 | bucket,
                data= (amb.TA),
                na.action=na.omit)
summary(mod.full)


#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages

# Perform Levene's test for variance homogeneity
levene_test_result <- leveneTest(thick.mgmm2 ~ factor(sal.treat.x), data = amb.TA)
# Summarize the Levene's test result
print(levene_test_result)

#Normality: looking for Gaussian distribution
hist((amb.TA$thick.mgmm2)) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. NO DIFFERENCE
mod.full <- lme((thick.mgmm2) ~ factor(sal.treat.x),
                random  = ~1 | bucket,
                data= (amb.TA),
                na.action=na.omit)
summary(mod.full)

```
         
        MODEL 2: How does the effect of [TA] on shell growth (surface area) at ambient and lower salinity change over time?
        
###ambient salinity

incremental split on shell growth? growth declined in latter half of experiment overall. in the latter half of the experiment the high TA treatment had higher incremental growth than the two low TA treatments
```{r}
boxplot(incr_growth.d ~ dps + round(med.ta,-3), data = inc[inc$med.S > 31,], outline = F)

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages
inc$dps.F = as.factor(inc$dps)
# Perform Levene's test for variance homogeneity
#levene_test_result <- leveneTest(incr_growth.d ~ dps.F, data = inc[inc$sal.treat.x == "amb",])
# Summarize the Levene's test result
#print(levene_test_result)
# Perform Levene's test for variance homogeneity
#levene_test_result <- leveneTest(incr_growth.d ~ factor(TA.treat.x), data = inc[inc$sal.treat.x == "amb",])
# Summarize the Levene's test result
#print(levene_test_result)

#inc$incr_growth.d.TRANS = as.numeric(sqrt(inc$incr_growth.d+5))

#model with all predictors. 
mod.full <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S > 31,]),
                na.action=na.omit)

# Calculate weights based on squared residuals (variance of the error terms)
mod.full.w <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S > 31,]),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))  # Use the inverse of squared residuals as weights)
  #it is an improved fit! Good to go.
anova(mod.full, mod.full.w)

# Residuals vs. Fitted Values
plot(mod.full.w)

# Normality of Residuals
qqnorm(resid(mod.full.w))
qqline(resid(mod.full.w))

# Homoscedasticity of Residuals
plot(resid(mod.full.w) ~ fitted(mod.full.w))


#Independence: added in bucket as a random intercept

#model with all predictors. 
mod.full <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S > 31,]),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))  # Use the inverse of squared residuals as weights)

summary(mod.full)

#Normality: looking for Gaussian distribution
hist(resid(mod.full)) #looks okay!
plot(resid(mod.full) ~ amb.TA$Net_growth.d)
plot(mod.full) #std resid vs fitted values looks okay!

#KEEP THE RANDOM EFFECT. 

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S > 31,]),
                na.action=na.omit)

# Fit the null model without the random effect
mod.null <- gls(incr_growth.d ~ TA.treat.x * dps.F,
                data= (inc[inc$med.S > 31,]),
                na.action=na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE


#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 25.82, p = 3.749e-07

#FINAL MODEL
mod.final = lme((Net_growth.d) ~ SA.start + 
                factor(sal.treat.x),
                random = ~1 | bucket,
                data = (amb.TA),
                weights = varIdent(form = ~ 1 | sal.treat.x),  # Use the inverse of squared residuals as weights
                na.action = na.omit)
summary(mod.final)

r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c

```
  
###low salinity

incremental split on area surface area growth? 
```{r}

boxplot(incr_growth.d ~ dps + round(med.ta,-2), data = inc[inc$med.S < 31,], outline = F)

#MEETING ASSUMPTIONS:

#To test for variance homogeneity among treatment groups in a mixed-effects model, you can use Levene's test or Bartlett's test. These tests compare the variances of the dependent variable (Net_growth.d) across different levels of the factor variable (TA.treat.x) to determine if the variances are approximately equal.
# Load the necessary packages
inc$dps.F = as.factor(inc$dps)
# Perform Levene's test for variance homogeneity
#levene_test_result <- leveneTest(incr_growth.d ~ dps.F, data = inc[inc$sal.treat.x == "amb",])
# Summarize the Levene's test result
#print(levene_test_result)
# Perform Levene's test for variance homogeneity
#levene_test_result <- leveneTest(incr_growth.d ~ factor(TA.treat.x), data = inc[inc$sal.treat.x == "amb",])
# Summarize the Levene's test result
#print(levene_test_result)

#inc$incr_growth.d.TRANS = as.numeric(sqrt(inc$incr_growth.d+5))

#model with all predictors. 
mod.full <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit)

# Calculate weights based on squared residuals (variance of the error terms)
mod.full.w <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit,
                weights = varIdent(form = ~ 1 | TA.treat.x))  # Use the inverse of squared residuals as weights)
  #it is an improved fit! Good to go.
anova(mod.full, mod.full.w)

# Residuals vs. Fitted Values
plot(mod.full)

# Normality of Residuals
qqnorm(resid(mod.full))
qqline(resid(mod.full))

# Homoscedasticity of Residuals
plot(resid(mod.full) ~ fitted(mod.full))


#Independence: added in bucket as a random intercept

#Normality: looking for Gaussian distribution
hist(resid(mod.full)) #looks okay!

#KEEP THE RANDOM EFFECT. 

library(lme4)
# Fit the full model with the random effect
mod.full <- lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit)

# Fit the null model without the random effect
mod.null <- gls(incr_growth.d ~ TA.treat.x * dps.F,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit)

# Perform the likelihood ratio test

#for table: 
anova(mod.full, mod.null)    #effect of RE


#compare the models
anova(mod.full, mod.sa) #LLR/Chi sq value = 25.82, p = 3.749e-07

#FINAL MODEL
mod.final = lme(incr_growth.d ~ TA.treat.x * dps.F,
                random  = ~1 | bucket,
                data= (inc[inc$med.S < 31,]),
                na.action=na.omit)
summary(mod.final)

r.squaredGLMM(object = mod.final, null = mod.RE)
  #r2m WHAT WE ARE INTERESTED IN?
 #r2c


```

        MODEL 3: What is the effect of [TA] on tissue growth at ambient and lower salinity?
        
###tissue wt NO EFFECT
```{r}
#looking at the effect of TA (vs omega?) on gut
boxplot(end$gut.wt ~ end$sal.treat.x*end$TA.treat.x, outline = F)

# Perform Levene's test for variance homogeneity
levene_test_result1 <- leveneTest(gut.wt ~ factor(TA.treat.x), data = end)
levene_test_result2 <- leveneTest(gut.wt ~ factor(sal.treat.x), data = end)
# Summarize the Levene's test result  PASSED TEST
print(c(levene_test_result1, levene_test_result2))

#Normality: looking for Gaussian distribution
hist(end$gut.wt) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. 
# Fit the full model
mod.full <- lme(gut.wt ~ factor(T.), random = ~1 | bucket, data = end, na.action = na.omit)


# Perform the ANOVA to test the significance of the factor
summary(mod.full)

#KEEP THE RANDOM EFFECT. 
# Fit the mixed-effects model
mod.full <- lme(gut.wt ~ factor(T.), random  = ~1 | bucket, data= end, na.action=na.omit)
#Test the significance of random effects (ie; test how much variance is accounted for by REs)
mod.RE <- gls(gut.wt ~ factor(T.), data= end, na.action=na.omit)
#mod.test<- gls(sqrt(Richness)~NAP*fExposure,method="REML",data=rikz)#remove the random effect; need to use gls bc lme/lme have to have a RE listed
#compare the two models; runs Log Likelihood Ratio test to test effect of random effect in model; P VALUE SAYS EFFECT OF BIN IS IMPORTANT.

#bucket does not contribute signifincant variance

#for table: 
anova(mod.full, mod.RE)    #effect of RE

#FINAL MODEL
mod.final = lme(gut.wt ~ factor(T.), random  = ~1 | bucket, data= end, na.action=na.omit)
```

###tissue versus condition index NO EFFECT
```{r}
#looking at the effect of TA (vs omega?) on gut and CI
boxplot(end$CI
        ~ end$sal.treat.x*end$TA.treat.x, outline = F)

# Perform Levene's test for variance homogeneity
levene_test_result1 <- leveneTest(CI ~ factor(TA.treat.x), data = end)
levene_test_result2 <- leveneTest(CI ~ factor(sal.treat.x), data = end)
# Summarize the Levene's test result  PASSED TEST
print(c(levene_test_result1, levene_test_result2))

#Normality: looking for Gaussian distribution
hist(end$gut.wt) #looks okay!

#Independence: added in bucket as a random intercept

#model with all predictors. 
# Fit the full model
mod.full <- lme(CI ~ factor(T.), random = ~1 | bucket, data = end, na.action = na.omit)


# Perform the ANOVA to test the significance of the factor
summary(mod.full)

#KEEP THE RANDOM EFFECT. 
# Fit the mixed-effects model
mod.full <- lme(CI ~ factor(T.), random  = ~1 | bucket, data= end, na.action=na.omit)
#Test the significance of random effects (ie; test how much variance is accounted for by REs)
mod.RE <- gls(CI ~ factor(T.), data= end, na.action=na.omit)
#mod.test<- gls(sqrt(Richness)~NAP*fExposure,method="REML",data=rikz)#remove the random effect; need to use gls bc lme/lme have to have a RE listed
#compare the two models; runs Log Likelihood Ratio test to test effect of random effect in model; P VALUE SAYS EFFECT OF BIN IS IMPORTANT.

#bucket does contribute signifincant variance

#for table: 
anova(mod.full, mod.RE)    #effect of RE

#FINAL MODEL
mod.final = lme(gut.wt ~ factor(T.), random  = ~1 | bucket, data= end, na.action=na.omit)
```
      
      Supplementary info and calculations:
      
###mortality/loss
```{r}
mort = dat %>%
  # first sort by year
  group_by(T.) %>% summarise(mort = (49*2) - mean(nrow),mort.frac = mort/(49*2), ave.tiss = mean(gut.wt), ave.net.d = mean(Net_growth.d))

dat$mort = NA
dat[dat$T. == "T1",]$mort <- mort[mort$T. == "T1",]$mort.frac
dat[dat$T. == "T2",]$mort <- mort[mort$T. == "T2",]$mort.frac
dat[dat$T. == "T3",]$mort <- mort[mort$T. == "T3",]$mort.frac
dat[dat$T. == "t1",]$mort <- mort[mort$T. == "t1",]$mort.frac
dat[dat$T. == "t2",]$mort <- mort[mort$T. == "t2",]$mort.frac
dat[dat$T. == "t3",]$mort <- mort[mort$T. == "t3",]$mort.frac

dat$surv = NA
dat$surv = 1 - dat$mort

# mort vectors
T1m = mean(dat[dat$T. == "T1",]$mort)
T2m = mean(dat[dat$T. == "T2",]$mort)
T3m = mean(dat[dat$T. == "T3",]$mort)
t1m = mean(dat[dat$T. == "t1",]$mort)
t2m = mean(dat[dat$T. == "t2",]$mort)
t3m = mean(dat[dat$T. == "t3",]$mort)
  
# combine two vectors using cbind 
# function
mort_data=cbind(T1m,T2m, T3m, t1m, t2m, t3m)


  dat$nrow.plate = NA
#to figure out how to get plate level mortality for the error bars
  # Iterate over each plate#
for (plate in 1:12) {
  # Subset data for the current Bin#
  subset_data <- end[end$Plate.x == plate, ]
  
  # Calculate the median TA for the current Bin#
  nrow.plate <- nrow(subset_data)
  
  # Assign the median value to the corresponding row in the final result dataframe
  dat[dat$Plate.x == plate, "nrow.plate"] <- nrow.plate
}
  SE.T1 = mean(unique(dat[dat$T. == "T1",]$mort))/sqrt(2)
  SE.T2 = mean(unique(dat[dat$T. == "T2",]$mort))/sqrt(2)
  SE.T3 = mean(unique(dat[dat$T. == "T3",]$mort))/sqrt(2)
  SE.t1 = mean(unique(dat[dat$T. == "t1",]$mort))/sqrt(2)
  SE.t2 = mean(unique(dat[dat$T. == "t2",]$mort))/sqrt(2)
  SE.t3 = mean(unique(dat[dat$T. == "t3",]$mort))/sqrt(2)
  
# pass this college_data to the 
# barplot
barplot(1-mort_data,beside=T, xaxt='n', ann=FALSE, yaxt='n', xlim = c(0,13), ylim = c(0,1))
lines(x = c(0,15),y=c(0,0), lwd = 1.5)
lines(x = c(0,0),y=c(0,1), lwd = 1.5)
axis(side = 2, labels = c("0","0.2","0.4","0.6","0.8","1.0"), at = c(0,0.2,0.4,0.6,0.8,1), las = 1, tick = F, line = -1.25)
axis(side = 2, labels = "Proportion survival", at = 0.5, cex = 1.5, line = 0.75, tick = F)
axis(side = 1, labels = c("ambient (S = 34)","low (S = 27)"), at = c(3.5,9.5), cex = 1.5, line = -0.5, tick = F)
  axis(side = 1, labels = c("X","X","X"), at = c(1.5,3.5,5.5), cex = 1.5, line = 0.75, tick = F)
    axis(side = 1, labels = c("X","X","X"), at = c(7.5,9.5,11.5), cex = 1.5, line = 0.75, tick = F)
  axis(side = 1, labels = c("total alkalinity concentration"), at = c(6.5), cex = 1.5, line = 2, tick = F)
  abline(h=0.9, lty = 2, lwd = 2)
  lines(x = c(1.5,1.5), y = c((1-T1m)+SE.T1, (1-T1m)-SE.T1), lwd = 2)
    lines(x = c(3.5,3.5), y = c((1-T2m)+SE.T2, (1-T2m)-SE.T2), lwd = 2)
    lines(x = c(5.5,5.5), y = c((1-T3m)+SE.T3, (1-T3m)-SE.T3), lwd = 2)
    lines(x = c(7.5,7.5), y = c((1-t1m)+SE.t1, (1-t1m)-SE.t1), lwd = 2)
    lines(x = c(9.5,9.5), y = c((1-t2m)+SE.t2, (1-t2m)-SE.t2), lwd = 2)
    lines(x = c(11.5,11.5), y = c((1-t3m)+SE.t3, (1-t3m)-SE.t3), lwd = 2)
  

```

###patterns of controls for ablines in figures...NOT DONE
```{r}
# SHELL WEIGHT 
plot(control$shell.wt~control$SA.mm2)
abline(lm(control$shell.wt~control$SA.mm2)) #relat between SA and wt

#after treatments
plot(end$shell.wt ~ end$SA.mm2, pch = 19, col = as.factor(end$bucket))
#add back the trend from control/
abline(lm(control$shell.wt~control$SA.mm2)) #relat between SA and wt

#writing a model that compares the slope of each treatment (n=2 bins) to the control.
mod.slope = lm(shell.wt ~ SA.mm2 + med.S + med.ta, data = end)
summary(mod.slope) #Shell wt both went up about 0.2 g per unit increase in SA mm2...it was a little higher but still similar to control. 

# TISSUE WEIGHT
boxplot(control$gut.wt~control$Plate)
summary(lm(control$gut.wt~factor(control$Plate))) #relat between gut and pre or post
# gut weight 2.24 post ave and 5.1 pre ave

#after treatments
boxplot(end$gut.wt ~ round(end$med.S,0), pch = 19)
#add back the trend from control/
boxplot(end$gut.wt ~ round(end$med.ta,-2), pch = 19)
abline(h = c(2.24,5.1),lty = 2) #relat between SA and wt

# CONDITION INDEX
boxplot((gut.wt/shell.wt)~Plate, data = control)
summary(lm((control$gut.wt/control$shell.wt)~factor(control$Plate))) #relat between gut and pre or post
# gut weight 0.0089 post ave and 0.0076 pre ave

#after treatments
boxplot((end$gut.wt/end$shell.wt) ~ round(end$med.S,0), pch = 19)
#add back the trend from control/
boxplot(end$CI ~ round(end$med.ta,-2), pch = 19)
abline(h = c(0.0089,0.0076),lty = 2) #relat between SA and wt

#quick model to see if 2000 is higher?
summary(lm(end$CI ~ factor(round(end$med.ta,-2))))

```

###average shell area, tissue mass, CI
```{r}
m.gut = mean(end$gut.wt)
se.gut = mean(end$gut.wt)/sqrt(nrow(end))

m.gut2 = mean(control$gut.wt)
se.gut2 = mean(control$gut.wt/sqrt(nrow(control)))

m.ci = mean(end$CI)
se.ci = mean(end$CI)/sqrt(nrow(end))

m.ci2 = mean(control$gut.wt/control$shell.wt)
se.ci2 = mean((control$gut.wt/control$shell.wt)/sqrt(nrow(control)))

m.area = mean(end$SA.mm2.RE)
se.area = mean(end$SA.mm2.RE)/sqrt(nrow(end))

m.area2 = mean(control$SA.mm2)
se.area2 = mean(control$SA.mm2/sqrt(nrow(control)))

```


      FIGURES:

###Figure 2: treatment conditions
summarizing conditions first
```{r}
median.sw.conditions <- sw %>%
  group_by(Date, `Bucket#`) %>%
  summarize(med_TA = median(TA), med_S = median(S), med_pH = median(pH), med_T = median(T_c), S.treat = NA, TA.treat = NA)

median.sw.conditions[median.sw.conditions$med_S > 30,]$S.treat <- 34
median.sw.conditions[median.sw.conditions$med_S < 30,]$S.treat <- 27

median.sw.conditions = median.sw.conditions[median.sw.conditions$`Bucket#` != 7 | median.sw.conditions$`Bucket#` != 14,]

median = median.sw.conditions %>%
  group_by(`Bucket#`) %>%
  summarize(med.TA = median(med_TA), med.S = median(med_S), med.T = median(med_T), med.pH = median(med_pH))

par(mfrow = c(1,1), mar = c(4, 5, 1.5, 2))

```
now for the figures...
```{r}
############Total alkalinity monitoring

#amb sal
plot(med_TA ~ Date, 
     data = median.sw.conditions[median.sw.conditions$S.treat == 34,],
     pch = 19,
     col = "black",
     ylim = c(500,3200),
     las = 1,
     xlab = NA,
     ylab = NA,
     xaxt='n',
     bty = 'n',
     axes = F,
     xlim=c(as.Date("2022-08-02"),as.Date("2022-09-05")))

#ambient salinity treatments
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(967,967), lwd = 2, lty = 2, col = "grey")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(942,942), lwd = 2, lty = 2, col = "grey")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(1969,1969), lwd = 2, lty = 2, col = "skyblue1")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(1941,1941), lwd = 2, lty = 2, col = "skyblue1")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(2900,2900), lwd = 2, lty = 2, col = "goldenrod1")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(2916,2916), lwd = 2, lty = 2, col = "goldenrod1")

points(med_TA ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 34,], pch = 19, col = "black", cex = 1.25)

#low salinity treatments
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(783,783), lwd = 2, lty = 2, col = "grey24")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(798,798), lwd = 2, lty = 2, col = "grey24")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(1499,1499), lwd = 2, lty = 2, col = "blue4")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(1470,1470), lwd = 2, lty = 2, col = "blue4")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(2212,2212), lwd = 2, lty = 2, col = "green4")
lines(x=c(as.Date("2022-08-02"),as.Date("2022-09-05")), y = c(2185,2185), lwd = 2, lty = 2, col = "green4")

points(med_TA ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 27,], pch = 17, col = "black", cex = 1.25)


lines(x=c(as.Date("2022-08-01"),as.Date("2022-09-05")), y=c(500,500), lwd = 2)
lines(x=c(as.Date("2022-08-01"),as.Date("2022-08-01")), y=c(500,3500), lwd = 2)

axis(side = 1, line = -1, at = c(as.Date("2022-08-05"), as.Date("2022-08-18"), as.Date("2022-08-30")), labels = c("Aug 03","Aug 18","Sept 02"), cex.axis = 1.15, tick = F)

axis(side = 1, line = 0.25, tick = F, at = as.Date("2022-08-18"), labels = "Date", cex.axis = 1.25)

axis(side = 2, line = -1, tick = F, at = c(1000,2000,3000), labels = c("1000","2000","3000"), cex.axis = 1.25, las = 1)

axis(side = 2, line = 2.5, tick = F, at = 2000, labels = 'Total alkalinity ', cex.axis = 1.15)
axis(side = 2, line = 1.25, tick = F, at = 2000, labels = expression(paste('(umol kg'^-1,')')), cex.axis = 1.15)

# Create an empty plot (blank screen)
plot(1, type = "n", xlab = "", ylab = "", xlim = c(0, 1), ylim = c(0, 1))
# Add legend for S treatment
legend("topleft", legend = unique(median.sw.conditions$S.treat), col = "black", pch = c(17,19), title = "Salinity", cex = 1.3, pt.cex = 2)

data_sorted <- median[order(median$med.TA),]
# Add legend for TA treatment
legend("topright", legend = c(783,798,967,942,
  1470,1499,1969,1942,
  2185,2212,2900,2916), col = c("grey24", "grey24","grey","grey","blue4", "blue4", "skyblue1", "skyblue1","green4","green4", "goldenrod1", "goldenrod1"), pch = 15, title = "Average TA", cex = 1.1, pt.cex = 2)

############Temperature monitoring

plot(med_T ~ as.Date(Date), 
     data = median.sw.conditions,
     pch = 18,
     col = "black",
     las = 1,
     xlab = NA,
     ylab = NA,
     xaxt='n',
     bty = 'n',
     axes = F,
     ylim = c(10,30),
     xlim=c(as.Date("2022-08-02"),as.Date("2022-09-05")))

points(med_T ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 34,], pch = 19, col = "black", cex = 1.25)
points(med_T ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 27,], pch = 17, col = "black", cex = 1.25)

lines(x=c(as.Date("2022-08-01"),as.Date("2022-09-05")), y=c(10,10), lwd = 2)
lines(x=c(as.Date("2022-08-01"),as.Date("2022-08-01")), y=c(10,23), lwd = 2)

axis(side = 2, line = -1, tick = F, at = c(11,16,21), labels = c("10","15","20"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.25, tick = F, at = 16.5, labels = "Temperature (C)", cex.axis = 1.15)

axis(side = 1, line = -1, at = c(as.Date("2022-08-05"), as.Date("2022-08-18"), as.Date("2022-08-30")), labels = c("Aug 03","Aug 18","Sept 02"), cex.axis = 1.15, tick = F)

axis(side = 1, line = 0.25, tick = F, at = as.Date("2022-08-18"), labels = "Date", cex.axis = 1.25)

############Salinity monitoring

plot(med_S ~ as.Date(Date), 
     data = median.sw.conditions,
     pch = 18,
     col = "black",
     las = 1,
     xlab = NA,
     ylab = NA,
     xaxt='n',
     bty = 'n',
     axes = F,
     ylim = c(24,36),
     xlim=c(as.Date("2022-08-02"),as.Date("2022-09-05")))

points(med_S ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 34,], pch = 19, col = "black", cex = 1.25)
points(med_S ~ as.Date(Date), data = median.sw.conditions[median.sw.conditions$S.treat == 27,], pch = 17, col = "black", cex = 1.25)

lines(x=c(as.Date("2022-08-01"),as.Date("2022-09-05")), y=c(24,24), lwd = 2)
lines(x=c(as.Date("2022-08-01"),as.Date("2022-08-01")), y=c(24,38), lwd = 2)

axis(side = 2, line = -1, tick = F, at = c(27,34), labels = c("27","34"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.5, tick = F, at = 29, labels = "Salinity", cex.axis = 1.15)

axis(side = 1, line = -1, at = c(as.Date("2022-08-05"), as.Date("2022-08-18"), as.Date("2022-08-30")), labels = c("Aug 03","Aug 18","Sept 02"), cex.axis = 1.15, tick = F)

axis(side = 1, line = 0.25, tick = F, at = as.Date("2022-08-18"), labels = "Date", cex.axis = 1.25)


```

###Figure 3:what is the effect of TA on surface area growth rate?
```{r}
boxplot(((amb.S$Net_growth.d)) ~ amb.S$TA.treat.x, pch = 19, ylab = NA, xlab = NA, names= NA, ylim = c(-0.6,1.8), frame.plot = F, xlim = c(0.25,4), axes = F)
lines(x= c(0.25,4), y=c(-0.6,-0.6), lwd = 2)
lines(x= c(0.25,0.25), y=c(-0.6,3), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'low'","~'ambient'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(-0.5,0,0.5,1.0,1.5), labels = c("-0.5","0","0.5", "1.0", "1.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 0.5, labels = 'Net surface area growth rate', cex.axis = 1.15)
axis(side = 2, line = 0.2, tick = F, at = 0.5, labels = expression(paste('(mm'^2,' d'^-1,')')), cex.axis = 1.15)

```

###Figure 4: Effect of TA in lower S on surface area growth rate?
```{r}
boxplot(Net_growth.d ~ TA.treat.x, pch = 19, ylab = NA, xlab = NA, names= NA, ylim = c(-0.6,1.7), frame.plot = F, xlim = c(0.25,4), axes = F, data = low.S, outline = F)
lines(x= c(0.25,4), y=c(-0.6,-0.6), lwd = 2)
lines(x= c(0.25,0.25), y=c(-0.6,3), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'DI'","'low TA'","'high TA'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Fresh water source", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(-0.5,0,0.5,1.0,1.5), labels = c("-0.5","0","0.5", "1.0", "1.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.75, tick = F, at = 0.5, labels = 'Net surface area growth rate', cex.axis = 1.15)
axis(side = 2, line = 0.2, tick = F, at = 0.5, labels = expression(paste('(mm'^2,' d'^-1,')')), cex.axis = 1.15)

text(x = 1, y = 1.25, label = "a", cex = 1.15)
text(x = 2, y = 0.75, label = "a", cex = 1.15)
text(x = 3, y = 1.7, label = "b", cex = 1.15)
```

###Figure 5: Incremental shell growth (all treatments; two plots pasted side by side after)
```{r}

#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
boxplot(incr_growth.d ~ dps : TA.treat.x, ylab = NA, xlab = NA, col = unique(c("grey","grey40")), names= NA, ylim = c(-1,3.6), frame.plot = F, xlim = c(0.5,9), axes = F, data = dat[dat$sal.treat.x == "amb",], outline = F)
#text(x = 7.5, y = 2.9, labels = c("Time increment"), cex = 1.25)
#legend(x=6,y=2.85,fill = c("grey","grey40"),legend = c("0 - 18 dps","18 - 36 dps"),bty = "n", cex = 1.2, x.intersp=0.4)
lines(x= c(0.25,7), y=c(-1,-1), lwd = 2)
lines(x= c(0.25,0.25), y=c(-1,3.5), lwd = 2)
axis(side = 1, line = -0.9, tick = F, at = c(1.5,3.5,5.5), labels = c("'low'","~'ambient'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 3.5, labels = "Total alkalinity condition", cex.axis = 1.1)

axis(side = 2, line = -0.75, tick = F, at = c(-.5,.5,1.5,2.5,3.5), labels = c("-0.5","0.5","1.5","2.5", "3.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 2.1, tick = F, at = 1.25, labels = 'Incremental growth rate', cex.axis = 1.1)
axis(side = 2, line = 0.75, tick = F, at = 1.25, labels = expression(paste(' (mm'^2,' d'^-1,')')), cex.axis = 1.1)

text(x = c(1,3,5), y = c(3.5,2.75,2.5), label = "a", cex = 1.15)
text(x = 6, y = 1.75, label = "b", cex = 1.15)
text(x = c(2,4), y = c(1,1.5), label = "c", cex = 1.15)



#LOW SALINITY
#incremental growth rates decline in amb TA conditions, suggesting that maybe the effect of altered
boxplot(incr_growth.d ~ dps : TA.treat.x, pch = 19, ylab = NA, xlab = NA, col = unique(c("grey","grey40")), names= NA, ylim = c(-1,3.6), frame.plot = F, xlim = c(0.5,9), axes = F, data = dat[dat$sal.treat.x == "low",], outline = F)
text(x = 7.5, y = 2.9, labels = c("Time increment"), cex = 1.25)
legend(x=6,y=2.85,fill = c("grey","grey40"),legend = c("0 - 18 dps","18 - 36 dps"),bty = "n", cex = 1.2, x.intersp=0.4)
lines(x= c(0.25,7), y=c(-1,-1), lwd = 2)
lines(x= c(0.25,0.25), y=c(-1,3.5), lwd = 2)
axis(side = 1, line = -0.9, tick = F, at = c(1.5,3.5,5.5), labels = c("'DI'","'Low TA'","'High TA'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 3.5, labels = "Total alkalinity condition", cex.axis = 1.1)

axis(side = 2, line = -0.75, tick = F, at = c(-.5,.5,1.5,2.5,3.5), labels = c("-0.5","0.5","1.5","2.5", "3.5"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 2.1, tick = F, at = 1.25, labels = 'Incremental growth rate', cex.axis = 1.1)
axis(side = 2, line = 0.75, tick = F, at = 1.25, labels = expression(paste(' (mm'^2,' d'^-1,')')), cex.axis = 1.1)

text(x = c(1,2,3,4,5,6), y = c(2.5,1,1.75,1,3.6,1.6), label = c("b","d","c","d","a","c"), cex = 1.15)
```

###extra/supplementary?
CI
```{r}
#effect of TA and amb on condition index
boxplot(CI ~ TA.treat.x, data = amb.S, outline = F,ylim = c(0.005,0.03), ylab = NA, xlab = NA, names= NA, frame.plot = F, xlim = c(0.25,3.5), axes = F)
lines(x= c(0.25,4), y=c(0.005,0.005), lwd = 2)
lines(x= c(0.25,0.25), y=c(0.005,0.03), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'low'","~'ambient'","'high'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(0.006,0.0105,0.015,0.02,0.025,0.03), labels = c("0.005","0.01","0.015","0.02","0.025","0.03"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.5, tick = F, at = 0.0175, labels = 'Condition index (tissue/shell mass)', cex.axis = 1.25)
        
#effect of TA on condition index low salinity
boxplot(CI ~ TA.treat.x, data = low.S, outline = F,ylim = c(0.005,0.03), ylab = NA, xlab = NA, names= NA, frame.plot = F, xlim = c(0.25,3.5), axes = F)
lines(x= c(0.25,4), y=c(0.005,0.005), lwd = 2)
lines(x= c(0.25,0.25), y=c(0.005,0.03), lwd = 2)
axis(side = 1, line = -1.25, tick = F, at = c(1,2,3), labels = c("'DI'","'Low TA'","'High TA'"), cex.axis = 1.1)
axis(side = 1, line = 0.25, tick = F, at = 2, labels = "Total alkalinity condition", cex.axis = 1.15)
axis(side = 2, line = -1.5, tick = F, at = c(0.006,0.0105,0.015,0.02,0.025,0.03), labels = c("0.005","0.01","0.015","0.02","0.025","0.03"), cex.axis = 1.25, las = 1)
axis(side = 2, line = 1.5, tick = F, at = 0.0175, labels = 'Condition index (tissue/shell mass)', cex.axis = 1.25)

```


Seawater table with carbonate system parameters listed for each treatment (ave +- SE)
```{r}
plot(end$med.OmC
     )

```

#not significant; incremental growth per start area (dps = 0, dps = 18); survival
```{r}
inc$incr_growth.d.mm2 = NA
inc$SA.mod = NA
inc[inc$dps == 18,]$incr_growth.d.mm2 = inc[inc$dps == 18,]$incr_growth.d/inc[inc$dps == 18,]$SA.start

inc[inc$dps == 18,]$SA.mod <- (inc[inc$dps == 18,]$SA.start)

inc[inc$dps == 36,]$SA.mod <- (inc[inc$dps == 36,]$SA.dps18)

inc[inc$dps == 36,]$incr_growth.d.mm2 = inc[inc$dps == 36,]$incr_growth.d/inc[inc$dps == 36,]$SA.dps18


summary(lme(incr_growth.d.mm2 ~ as.numeric(SA.mod) * as.factor(dps), random = ~1|bucket, data = inc))


#Figure 
boxplot(inc$incr_growth.d.mm2 ~ inc$dps)


#extra figure to alter
plot(inc$incr_growth.d.mm2 ~ inc$SA.mod, bty = "n", type = "n", axes = F, xlim = c(50,300), ylim = c(-0.012,0.03), xlab = NA, ylab = NA)

points((inc[inc$dps == 36,]$incr_growth.d.mm2 ~ inc[inc$dps == 36,]$SA.mod), pch = 21, bg = "grey40")
points((inc[inc$dps == 18,]$incr_growth.d.mm2 ~ inc[inc$dps == 18,]$SA.mod), pch = 21, bg = "grey")
lines(x= c(50,300), y=c(-0.012,-0.012), lwd = 2)
lines(x= c(50,50), y=c(-0.012,0.03), lwd = 2)

axis(side = 1, line = -0.9, tick = F, at = c(53,100,150,200,250,300), labels = c("50","100","150","200","250","300"), cex.axis = 1.1)
axis(side = 1, line = 0.75, tick = F, at = 175, labels = "Size at start of increment (mm2)", cex.axis = 1.1)

axis(side = 2, line = -1.75, tick = F, at = c(-0.005,0.005,0.015,0.025), labels = c("-0.005","0.005","0.015","0.025"), cex.axis = 1.1, las = 2)
axis(side = 2, line = 2.25, tick = F, at = 0.01, labels = "incremental per area", cex.axis = 1.1)
axis(side = 2, line = 1.25, tick = F, at = 0.01, labels = "growth rate (d-1)", cex.axis = 1.1)

lines(x=c(55,300), y=c(0.0063,0.0063), lwd = 3, col = "grey", lty = 2) #intercept > 0 but slope == 0
lines(x=c(55,300), y=c(0.002788592,-0.0045456), lwd = 3, col = "grey40", lty = 2)
```
